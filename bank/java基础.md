1.死锁的条件，如何避免死锁

死锁：多个线程循环等待资源，线程被无限期地阻塞，程序无法正常终止。

原因：资源的竞争，资源申请的顺序不合理。

死锁的四个必要条件
```
1. 互斥条件:该资源任意一个时刻只由一个线程占用。
2. 请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
```
如何预防线程死锁
```
1. 破坏互斥条件 :这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的(临界 资源需要互斥访问)。
2. 破坏请求与保持条件 :一次性申请所有的资源。
3. 破坏不剥夺条件 :占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释
放它占有的资源。
4. 破坏循环等待条件 :靠按序申请资源来预防。进程在申请资源时必须按照序号递增的顺序进行资源的申请，释放资源则反序释放。
破坏循环等待条件。
```

银行家算法:银行家算法是一种死锁避免算法，该算法允许进程动态申请资源。系统毎次在进行资源分配之前,先计算此次分配资源的安全性,若此次资源分不会导致系统进入不安全状态,则分配资源；
否则,不分配资源,让进程等待。银行家算法在避免死锁上非常有效，但是需要在进程运行前就知道其所需资源的最大值，且进程数也通常不是固定的。因此很难实现。

已分配给进程的资源：Allocation

进程总共需要的资源数：Claim

进程还需要的资源数：Need

资源池(空闲资源数)：Available

银行家算法分配系统资源的原则
```java
(1)当一个进程对资源的最大需求量不超过系统中的资源数时可以接纳该进程。

(2)进程可以分期请求资源，但请求的总数不能超过最大需求量。

(3)当系统空闲的资源不能满足进程尚需资源数时，对进程的请求可以推迟分配，但总能使进程在有限的时间里得到资源。

(4)当系统空闲的资源能满足进程尚需资源数时，必须测试系统现存的资源能否满足该进程尚需的最大资源数，若能满足则按当前的申请量分配资源，否则也要推迟分配。
```
