[字符串排序](#字符串排序)

[拆分成多个连续自然数相加](#拆分成多个连续自然数相加)

[k进制字符串加法](#k进制字符串加法)

### 字符串排序

每个字符串至少含有一个数字字符，按如下规则降序排序：

（1）按照字符串中字母字符个数和数字字符个数（字母数字比）的比值大小进行排序。

（2)若两个字符串的字母数字比相同。则按照字符串本身大小进行排序。

#### 例子
```
输入值：["abc123","abc+1234","abcabab--1"]
返回值：["abcabab--1","abc123","abc+1234"]
```
#### 方法

输入是字符串数组，将其转为ArrayList集合，然后调用Collections的sort方法，传入自定义的比较器进行排序。
```java
public class SpecifySort1 {

    public String[] specify_sort(String[] words){
        ArrayList<String> list = new ArrayList<>();
        for(int i = 0;i < words.length;i++){
            list.add(words[i]);
        }
        Collections.sort(list, (x, y) ->{

            double a = count(x);
            double b = count(y);
            if(a == b){
                return y.compareTo(x);
            }
            if(a > b){
                return -1;
            }
            return 1;
        });

        String[] res = new String[list.size()];
        for(int i=0;i<res.length;i++){
            res[i] = list.get(i);
        }
        return res;
    }

    //测试
    public static void main(String[] args) {

        String[] words = new String[3];
        words[0] = "abc123";
        words[1] = "abc+1234";
        words[2] = "ababab--1//";

        SpecifySort1 specifySort = new SpecifySort1();
        String[] res = specifySort.specify_sort(words);
        for(String str : res){
            System.out.println(str);
        }
    }

    //求字母数字比
    private double count(String str){

        char[] chars = str.toCharArray();
        int alpha = 0;
        int digit = 0;
        for(char ch : chars){
            if(isAlpha(ch)){
                alpha++;
            }else if(isDigit(ch)){
                digit++;
            }
        }

        return 1.0*alpha/digit;
    }

    private boolean isAlpha(char ch){

        return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');
    }

    private boolean isDigit(char ch){

        return (ch >= '0' && ch <= '9');
    }
}

```
### 拆分成多个连续自然数相加

给定两个正整数：num和n，判断是否能把num分解成n个连续自然数相加的和。如果能分解，返回分解得到的n个自然数构成的列表（列表中的元素按升序排序）。如果不能分解，则返回一个空列表。

#### 例子

```
输入：num = 18, n = 4;
返回值：[3,4,5,6]
```

#### 方法一

等差数列的公式可知sum = n\*a1 + n(n-1)/2;

已知sum和n，可以求出a1，若a1为整数则能分解；若a1不是整数则不能分解。

```java
public Integer[] getSeq(int num, int n){

    int temp = num - n*(n-1)/2;
    if(temp%n == 0){
        int a = temp/n;
        Integer[] res = new Integer[n];
        for(int i=0;i<n;i++){
            res[i] = a + i;
        }
        return res;
    }
    return new Integer[0];
}
```

### k进制字符串加法

你不能使用任何內建BigInteger库， 也不能直接将输入的字符串转换为整数形式。

#### 方法

只需要对两个大整数模拟「竖式加法」的过程：将相同数位对齐，从低到高逐位相加。如果当前位和超过k,则向高位进以为，除k的余数为当前位，商为进位。

注意循环结束的条件，若i和j都小于0，但sum不为0时还要循环一次，最高位为sum，然后sum变为0，循环结束。

以三进制为例
```java
    public static String addStrings(String num1, String num2) {

        int n1 = num1.length();
        int n2 = num2.length();

        int i = n1 - 1;
        int j = n2 - 1;
        int sum = 0;
        StringBuilder sb = new StringBuilder();

        while(i >= 0 || j >= 0 || sum != 0){
            if(i>=0){
                sum = sum + num1.charAt(i--) - '0';
            }
            if(j>=0){
                sum = sum + num2.charAt(j--) - '0';
            }
            sb.append(String.valueOf(sum%3));   //sum%k
            sum = sum/3;    //sum/k
        }
        sb.reverse();//加入StringBuilder时，低位在前，所以返回前先翻转，让高位在前。
        return sb.toString();
    }
```
