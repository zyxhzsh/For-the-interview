[继承](#继承)

[super](#super)

[this](#this)

[抽象](#抽象)

[发红包案例](#发红包案例)

[接口](#接口)


### 继承

继承主要解决的问题是共性抽取。继承已存在的类就是复用这些类的方法和域。

父类也叫基类，超类;子类也叫派生类

继承关系的特点：

(1)子类可以拥有父类的内容。

(2)子类还可以拥有自己专有的内容。

- [继承的三个特点](#继承的三个特点)
- [继承的设计原则](#继承的设计原则)
- [继承的格式](#继承的格式)
- [区分子类中重名的三种变量](#区分子类中重名的三种变量)
- [继承中成员变量的的访问特点 ](#继承中成员变量的的访问特点 )
- [继承中成员方法的访问特点](#继承中成员方法的访问特点)
- [覆盖重写](#覆盖重写)
- [继承中构造方法的特点](#继承中构造方法的特点)

### 继承的三个特点

(1)Java语言是单继承的，一个类的直接父类只能有一个。

(2)Java语言可以多级继承。

(3)一个父类可以拥有多个子类。

### 继承的设计原则

对于已经投入使用的类，尽量不要进行修改。推荐定义一个新的类，重复利用其中共性内容，并且添加和覆盖重写新内容。

### 继承的格式

在继承的关系中，子类就是父类。也就是说子类可以被当做父类看待。

定义父类的格式和普通类的定义没有区别。

定义子类的格式：
```
public class 子类名称 extends 父类名称{

}
```
### 区分子类中重名的三种变量

父类的成员变量，子类的成员变量，子类方法中的局部变量，如果三者重名。

局部变量：直接写。

本类中的成员变量：this.变量名

父类的成员变量：super.变量名

### 继承中成员变量的的访问特点 

在父子类的继承关系当中，如果成员变量重名（没有重名也是这个寻找顺序），则创建子类对象时，访问有两种方式:

(1)直接通过子类对象访问成员变量

直接通过子类对象访问成员变量：new创建子类对象时，等号左边是哪个类，就优先用谁，没有则向上找。
```
Fu objectName = new Zi();
zi.num;//创建子类对象时，如果左边是Fu类，就优先用Fu类里的成员变量num,如果没有这个变量就向上找。

Zi objectName = new Zi();
zi.num;//创建子类对象时，如果左边是Zi类，就优先用Zii类里的成员变量num,如果没有这个变量就向上找。
```
(2)间接通过成员方法访问成员变量

方法属于哪个类，就优先用哪个类的成员变量，没有则向上找。


### 继承中成员方法的访问特点

在父子类的继承关系当中，如果成员方法重名（没有重名也是这个寻找顺序）：

创建的对象是那个类，就优先用哪个类的方法，如果没有就向上找。
```
Zi zi = new Zi();
zi.method();
右边new的是Z类，就优先用Zi类的method()方法。
```

无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类。

成员变量是从创建语句等号左边的类开始找，成员方法是从创建语句右边的类开始找。

### 覆盖重写

重写(Override)：在继承关系当中，方法的名称一样，参数列表也一样。

若父类方法的返回值类型是基本类型，子类不能修改返回值类型。若父类方法的返回值类型是引用类型，子类的返回值类型如果要修改，必须是父类方法的返回值类型的子类。重写也叫覆盖，覆写。

重载(Overload)：方法的名称一样，参数列表不一样。

方法的覆盖重写特点：创建的是哪个类的对象，就优先用哪个类的方法，没有就向上找。

**注意事项**：

（1）必须保证父子类直接的方法名称相同，参数列表也相同。

@Override:这是一个注解，写在方法的前面，用来检测是不是正确的覆盖重写。这是一个可选的安全检测手段，建议能写就写。

（2）子类方法的返回值如果要修改，必须是父类方法的返回值类型的子类。

注意基本数据类型不是类！所以如果父类方法的返回值类型是基本数据类型，子类就不能修改返回值类型。

如果父类方法的返回值类型是引用类型，子类的返回值类型如果要修改，必须是父类的子类，不能是基本数据类型，因为基本数据类型不是类，就不会有父类和子类。

java.lang.Object类是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类。

void是一个不可实例化的类，无返回值。若父类方法返回值Object类，子类方法的返回值不能是void，因为一个有返回值一个无返回值。

（3）子类方法的权限必须大于等于父类方法的权限修饰符。

public>protected>(default)>private

default不是关键字，而是什么都不写，留空。

(4)覆盖重写时如果要保留父类方法中的功能：super.方法名();

```java
父类    
    public void show(){
        System.out.println("显示号码");
    }
```
```java
子类
    @Override
    public void show() {
        super.show();//保留父类方法中的功能
        System.out.println("显示姓名");
        System.out.println("显示头像");
    }
```

### 继承中构造方法的特点

子类的构造方法必须要用super关键字，来调用父类的构造方法。而且子类的非构造方法无法调用父类构造方法，只有子类的构造方法才能调用父类的构造方法。

（1）子类构造方法中有一个默认隐含的"super()"调用，而且一定是先调用的父类构造，后执行的子类构造。如果父类中没有无参的构造方法，同时子类中没有调用父类重载构造，默认的super()调用就失败了，会报错。

（2）super的父类构造调用，必须是子类构造方法中的第一个语句。不能一个子类构造调用多次super构造，只能在第一个语句写调用一次。

总结：子类构造方法必须调用父类构造方法，不写则默认为super()；写了则用指定的super调用，super只能有一个，而且必须是构造方法的第一个语句。

### super

super关键字用来访问父类内容，主要有三种用法:

（1）在子类的成员方法中，访问父类的成员变量：super.父类成员变量名

（2）在子类的成员方法中，访问父类的成员方法：super.父类成员方法名

可以出现在子类成员方法中的任意位置。

（3）在子类的构造方法中，访问父类的构造方法：super(输入参数);

必须是子类的构造方法的第一个语句，只能调用一次。

子类构造方法的参数列表与父类构造方法的参数列表无关，可以任意定义。只是super里的参数，要和父类重载构造方法的参数类型一致。
```
父类   
    public Fu(int a) {
        System.out.println("父类构造方法");
    }
```
```
子类  
    public Zi() {
        super(10);
        System.out.println("子类构造方法");
    }
```

### this

this关键字用来访问本类内容，用法有三种：

（1）在本类的成员方法中，访问本类的成员变量：this.本类成员变量名

（2）在本类的成员方法中，访问本类的成员方法：this.本类成员方法名(可以访问其他成员方法，也可以递归调用自己)

（3）在本类的构造方法中，访问本类的另一个构造方法：this(参数)(构造方法不能自己调用自己)

构造方法中this()调用必须是第一个语句，且只能调用一次。

重载的构造方法之间，不能循环调用构造方法。
```
public class Zi extends Fu{
    int num = 0;
    public void method(){
        this.num=1;//在本类的成员方法中，访问本类的成员变量。
        this.method1();//在本类的成员方法中，访问本类的成员方法。
    }
    public void method1(){
    }

    public Zi(){
        this(12);//本类的无参构造，调用本类的有参构造
    }
    public Zi(int n){
        this(10,12);//调用本类两个参数的构造
    }
    }
    public Zi(int m, int n){
        super();//调用父类的无参构造
    }
}
```


**super和this两种构造调用，不能同时使用，因为他们各自都是唯一的，且必须是构造方法的第一个语句。**

### super与this的内存图

方法区先有内容。

main方法先进栈。

new出来的对象都在堆中。

子类对象中包含一个完整的父类结构，所以一定是先构造父类，再在父类的外围构造子类内容。

<div align="center"><img width="60%" src="super与this的内存图.png"></img></div>

### 抽象

如果父类当中的方法不确定如何进行方法体实现，那么这就是一个抽象方法。

抽象方法就是加上abstract关键字，然后去掉大括号，直接分号结束。

抽象方法所在的类必须是抽象类，抽象类及时在class之前写上abstract。抽象类中也可以定义普通方法。

### 抽象类和抽象方法的格式
```java
public abstract class Animal{

    //抽象方法
    public abstract void eat();

    //普通的成员方法
    public void noramlMethod(){

    }
}
```

### 抽象类和抽象方法分使用

（1）不能直接new抽象类对象。

（2）必须用一个子类继承抽象父类。子类必须覆盖重写（实现）抽象父类中所有的抽象方法，去掉abstract关键字和分号;，然后补上方法体大括号。

（3）创建子类对象进行使用。

### 注意事项

（1）抽象类不能创建对象，只能创建非抽象子类对象。

（2）抽象类可以有构造方法，是供子类创建对象时，初始化父类成员使用的。

抽象类的构造方法，只能通过子类的构造方法调用，且必须在方法体的第一个语句，默认为super();

（3）一个抽象类中不一定包含抽象方法。但抽象方法所在的类必须是抽象类。注意：即使抽象类没有抽象方法，也不能直接创建对象。设计模式中的适配器模式就可以使用没有抽象方法的抽象类。

（4）抽象类的子类如果不是抽象类，就必须覆盖重写父类的所有抽象方法。如果子类也是抽象类，就可以不覆盖重写抽象方法。

### 发红包案例

群主发普通红包。某群有多名成员，群主给成员发普通红包。普通红包的规则:

群主的一笔金额，从群主余额中扣除，平均分成n等份，让成员领取。

成员领取红包后，保存到成员余额中。

请根据描述，完成案例中所有类的定义以及指定类之间的继承关系，并完成发红包的操作。

[代码](https://github.com/GrowTowardsSunlight/For-the-interview/blob/master/java/案例.md#发红包案例)

### 接口

接口是多个类的公共规范。（只要符合规范标准，就可以大家通用）

接口是一种引用数据类型，最重要的内容就是其中的抽象方法。

- [定义格式](#定义格式)
- [接口的使用步骤](#接口的使用步骤)
- [接口的抽象方法](#接口的抽象方法)
- [接口的默认方法](#接口的默认方法)
- [接口的静态方法](#接口的静态方法)
- [接口的私有方法](#接口的私有方法)
- [接口的常量](#接口的常量)
- [继承父类并实现多个接口](#继承父类并实现多个接口)
- [接口之间的多继承](#接口之间的多继承)


### 定义格式

class换成关键字interface后，编译生成的字节码文件仍然是.class。
```
public interface 接口名称{

}
```
接口中能够包含的内容：

（1）常量（成员变量效果是全局常量）

（2）抽象方法

Java8额外包含：

（3）默认方法

（4）静态方法

Java9额外包含：

（5）私有方法

接口不能有静态代码块，也不能有构造方法。

### 接口的使用步骤

（1）接口不能直接使用，不能直接new接口对象，必须有一个实现类来实现该接口。

（2）接口的实现类必须覆盖重写（实现）接口中所有的抽象方法，除非这个实现类是抽象类。

实现：去掉abstract关键字和分号;，加上方法体的大括号。

实现类的格式:
```
public class 实现类名称 implements 接口名称{
    //接口的实现类必须覆盖重写（实现）接口中所有的抽象方法，除非这个实现类是抽象类。
}
```
实现类命名的建议：接口名称Impl

（3）创建实现类的对象，进行使用。


### 接口的抽象方法

接口中的抽象方法，修饰符必须是两个固定的关键字：public abstract。这两个关键字可以全省略或者省略一部分，但不能改成别的关键字。

方法的三要素没有要求，可以随意定义。
```java
public interface MyInterfaceABSTRACT {
    public abstract void method();//抽象方法
    public  void method1();//抽象方法
    abstract void method2();//抽象方法
    void method3();//抽象方法
}
```

### 接口的默认方法

(1)接口中的默认方法，可以解决接口升级问题：如果接口新添加了抽象方法，接口的所有实现类都要覆盖重写这个抽象方法，否则就会报错。但是不想修改它的所有实现类，就可以改为添加一个默认方法。

(2)接口的默认方法可以拼接函数模型。（lambda表达式和函数式编程的内容）

从java8开始，接口里允许定义默认方法。

格式：

public可以省略不写，但不能改成别的。
```
public default 返回值类型 方法名称(参数列表){

}
```

默认方法会被实现类继承，实现类中如果没有覆盖重写默认方法，会向上找接口。

接口的默认方法可以通过接口的实现类直接调用，也可以被接口的实现类覆盖重写。

```java
//接口
public interface MyInterfaceDefault {
    public abstract void method();
    public default void method2(){
        System.out.println("接口的默认方法");
    }
}

//实现类A，没有覆盖重写默认方法
public class MyInterfaceDefaultA implements MyInterfaceDefault{

    @Override
    public void method() {
        System.out.println("实现了抽象方法。AAA");
    }
}

//实现类B，覆盖重写了默认方法
public class MyInterfaceDefaultB implements MyInterfaceDefault{

    @Override
    public void method() {
        System.out.println("实现了抽象方法。BBB");
    }

    @Override
    public void method2() {
        System.out.println("实现类B覆盖重写了接口的默认方法");
    }
}

//main方法
public class Demo1Interface {
    public static void main(String[] args) {
        MyInterfaceDefaultA a = new MyInterfaceDefaultA();
        a.method();
        a.method2();
        MyInterfaceDefaultB b = new MyInterfaceDefaultB();
        b.method();
        b.method2();
    }
}
//打印结果
/*
实现了抽象方法。AAA
接口的默认方法
实现了抽象方法。BBB
实现类B覆盖重写了接口的默认方法
*/
```

### 接口的静态方法

从java8开始，接口中允许定义静态方法。

格式:

public可以省略不写，但不能改成别的。
```
public static 返回值类型 方法名称(参数列表){
    方法体;
}
```

**不能通过接口实现类的对象来调用接口中的静态方法**。

一个类可以实现多个接口，多个接口中的静态方法可能会产生冲突，所以不允许通过接口实现类的对象来调用接口中的静态方法。

通过接口名称直接调用其中的静态方法：接口名称.静态方法名(参数);

### 接口的私有方法

接口的私有方法用来解决两个默认方法之间重复代码问题。

私有方法只要接口自己才能调用，不能被实现类或别人使用。

**引例**：

如果两个方法的方法体中有很多重复的内容，就需要抽取。
```
    public default void methodDefault1(){
        System.out.println("默认方法1");
        System.out.println("AAA");
        System.out.println("BBB");
        System.out.println("CCC");
    }

    public default void methodDefault2(){
        System.out.println("默认方法2");
        System.out.println("AAA");
        System.out.println("BBB");
        System.out.println("CCC");
    }
```
抽取：
```

    public default void methodDefault1(){
        System.out.println("默认方法");
        methodCommon();
    }

    public default void methodDefault2(){
        System.out.println("默认方法");
        methodCommon();
    }

    public default void methodCommon(){
        System.out.println("AAA");
        System.out.println("BBB");
        System.out.println("CCC");
    }
```

本来是两个默认方法，但是变成了三个。而默认方法一定是public，如果又增加了一个方法，实现类也可以访问第三个默认方法。

问题描述：我们需要抽取一个公共方法，用来解决两个默认方法之间重复代码问题。但是这个公共方法不应该让实现类使用，应该是私有化的。

在这种情况下，应该使用接口的私有方法。（从java9开始，接口中允许定义私有方法）

（1）普通私有方法：解决多个默认方法之间重复代码问题。

（2）静态私有方法：解决多个静态方法之间重复代码问题。

普通私有方法格式：
```
private 返回值类型 方法名称(参数列表){
    方法体;
}
```

静态私有方法格式：
```
private static 返回值类型 方法名称(参数列表){
    方法体;
}
```

### 接口的常量

接口中也可以定义成员变量，但必须使用public static final三个关键字进行修饰，从效果上看，相当于全局常量。

如果有变量，就和接口提供的统一的抽象这种思想是抵触的。所以接口中的属性必然是常量，只能读不能改，这样才能为实现接口的对象提供一个统一的属性。

通俗的讲，你认为是要变化的东西，就放在你自己的实现中，不能放在接口中去，接口只是对一类事物的属性和行为更高层次的抽象。对修改关闭，对扩展（不同的实现implements）开放，接口是对开闭原则的一种体现。

格式：

三个关键字都可以省略。接口中的常量必须赋值。

推荐命名：常量名称全部大写，用下划线分隔。
```
public static final 数据类型 常量名称 = 数据值
数据类型 常量名称 = 数据值
```
使用：接口名称.常量名称。

使用final关键字进行修饰，说明不可改变。

### 继承父类并实现多个接口

类与接口之间是多实现的，一个类可以同时实现多个接口。注意多个接口和其直接父类中，如果有方法名相同，但返回值不同，那么无法解决冲突。

(1)如果多个接口中有重复的抽象方法，只需覆盖重写一次。

(2)如果多个接口中有重复的默认方法，实现类一定要对冲突的默认方法覆盖重写。

(3)如果实现类没有覆盖重写所有接口中的所有抽象方法，那么实现类必须是一个抽象类。

(4)继承优于接口实现：如果一个类的直接父类中的方法，和实现的接口中的默认方法重复了，优先使用父类中的方法。

### 接口之间的多继承

一个接口可以继承多个接口。注意多个接口中如果有方法名相同，但返回值不同，那么无法解决冲突。

多个父接口中的抽象方法如果重复，没关系，因为抽象方法没有方法体。

多个父接口中的默认方法如果重复，子接口必须覆盖重写默认方法
