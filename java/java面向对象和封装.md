- [类和对象的关系](#类和对象的关系)
- [类的定义](#类的定义)
- [对象的创建和使用](#对象的创建和使用)
- [对象类型作为方法的参数](#对象类型作为方法的参数)
- [对象类型作为方法的返回值](#对象类型作为方法的返回值)
- [成员变量和局部变量的区别](#成员变量和局部变量的区别)
- [匿名对象](#匿名对象)
-------------------------------------------------
- [封装性](#封装性)
- [private关键字](#private关键字)
- [this关键字](#this关键字)
- [构造方法](#构造方法)
- [标准类JavaBean](#标准类)
- [static关键字](#static)


面向过程：当需要实现一个功能时，每一个具体的步骤都亲力亲为，详细处理每个细节。

面向对象：当需要实现一个功能时，不关心具体的步骤，而是找已有该功能的类。

面向对象将我们从执行者变成了指挥者。面向对象的语言中，包含了三大基本特：封装、继承和多态。

### 类和对象的关系

类：一组相关的属性和行为的集合，可以看成一类事物的模板，使用事物的属性特征和行为特征来描述该类事物。

属性：事物的状态信息；行为：该类事物能够做什么。

对象：一类事物的具体体现，对象是类的一个实例，具备该类的属性和行为。

类是对一类事物的描述，是抽象的；对象是一类事物的实例，是具体的。

类是对象的模板，对象是类的实体。

### 类的定义

java的类中，属性叫成员变量，行为叫成员方法。

成员方法没有static关键字。

成员变量直接定义在类中，在成员方法外面。

```
public class Student {

    //成员变量
    String name;
    int age;

    //成员方法
    public void eat(){
        System.out.println("吃饭");
    }
    public void sleep(){
        System.out.println("睡觉");
    }
    public void study(){
        System.out.println("学习");
    }
}

```

### 对象的创建和使用

通常情况下，一个类不能直接使用，需要根据类创建一个对象才能使用。对象的名称也叫对象的引用名。

1.导包，作用是支出需要使用的类在什么位置。

import 包名称.类名称;

若需要使用的类和当前类属于同一个包，可以省略导包语句。

2.创建

类名称 对象名 = new 类名称();
Student stu = new Student();

成员变量没赋值时有默认值，和数据类型有关。

3.使用

使用成员变量：对象名.成员变量名

使用成员方法：对象名.成员方法名()

### 对象类型作为方法的参数

当一个对象类型作为参数传递到方法中时，实际传递进去的是对象的地址值。

### 对象类型作为方法的返回值

当一个对象类型作为方法的返回值时，返回值其实就是对象的地址。

### 成员变量和局部变量的区别

1.定义的位置不一样。

局部变量在方法的内部，成员变量在方法的外部，直接写在类中。

2.作用范围不一样。

局部变量只有在方法中才可以使用，成员变量整个类中都可以使用。

3.默认值不一样。

局部变量没有默认值，如果要使用必须先赋值。成员变量如果没有赋值会有默认值。

注意：方法的参数也是局部变量，虽然定义方法的时候没有赋值，但参数在方法调用的时候必然会被赋值。

4.内存的位置不一样。

局部变量位于栈内存（局部变量在方法内，而方法的运行是在栈中进行的）。成员变量位于堆内存（new对象的时候才有成员变量）

5.生命周期不一样。

局部变量随着方法进栈而诞生，随着方法出栈而消失。成员变量随着对象创建而诞生，随着对象被垃圾回收而消失。通常对象不会被马上回收，所以一般成员变量比局部变量生命周期长一点。

### 封装性

封装就是将一些细节信息隐藏起来，对于外界不可见。

1.方法就是一种封装。

2.关键字private也是一种封装。

### private关键字

一旦使用了private修饰，那么本类中仍然可以随意访问。但是超出了本类范围之外的就不能再直接访问了。

间接访问成员变量就是定义一对setter,getter方法。方法名为：set成员变量名，get成员变量名。

对于布尔类型的成员变量，getter方法应命名为：is成员变量名。

间接访问的方式可以在方法中写代码阻止不合理的数据被设置进来，提高了代码的安全性。

### this关键字

this代表当前对象，this主要用于在重名的时候起到区分的效果。

当方法的局部变量和类的成员变量重名的时候，根据就近原则，优先使用局部变量。如果需要访问本类中的成员变量，需要使用this.成员变量。this关键字可以解决重名无法区分的问题。谁调用的方法，谁就是this。

### 构造方法

构造方法是专门用来创建对象的方法，通过new来创建对象时，其实就是在调用构造方法。

构造方法的调用是通过new关键字。当用new关键字创建时，new后面的类名称其实就是构造方法名。
```
public 类名称(参数类型 参数名称){
    方法体;
}
```
注意事项：

1.构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样。

2.构造方法没有返回值类型，连void也不写。

3.构造方法不能return一个具体的返回值。

4.如果没有编写构造方法，编译器会默认产生一个构造方法，没有参数，方法体什么都不做。
如果编写了构造方法，编译器就不会产生默认的构造方法。
```
public Student(){};//编译器默认产生的构造方法,无参数。
```

5.构造方法也可以重载。

重载形式的全参数构造方法只是在创建对象时，更方便把现成的数据通过参数设置进来，而省去多次调用set方法。但是要修改对象的内容时，还是需要set方法。

### 标准类

一个标准类通常要有下面四个组成部分：
```
1.所有成员变量都要用private关键字修饰。
2.为每个成员变量编写一堆Getter/Setter方法。
3.编写一个无参数的构造方法。
4.编写一个全参数的构造方法。
```
这样标准的类也叫JavaBean。

### 匿名对象

匿名对象: 没有变量名的对象。匿名对象只能使用唯一的一次，下次再用不得不创建一个新对象。
```
new 类名称();
```
创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。虽然是创建对象的简化写法，但是应用场景非常有限。

如果确定有一个对象只需要使用唯一的一次，就可以使用匿名对象。

匿名对象可以作为方法的参数
```java
    public static void main(String[] args) {
        //一般写法传入参数
        Scanner sc = new Scanner(System.in);
        methodParam(sc);

        //匿名对象作为方法的参数
        methodParam(new Scanner(System.in));
    }

    public static void methodParam(Scanner sc){
        int num=sc.nextInt();
        System.out.println("输入的是"+num);
    }
```

匿名对象可以作为方法的返回值
```java
    public static void main(String[] args) {
            Scanner sc = methodReturn();
            int num = sc.nextInt();
            System.out.println("输入的是：" + num);
    }

    public static void methodParam(Scanner sc){
            int num=sc.nextInt();
            System.out.println("输入的是"+num);
    }
```

### static

可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属 于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。

静态内容总是优先于非静态。

#### static修饰成员变量

static修饰的成员变量叫做静态变量。当static修饰成员变量时,这个成员变量不属于某个对象，而是属于类的，所有属于本类的对象都共享同一份数据。

静态变量推荐使用类名称进行调用：类名称.静态变量（虽然对象名也能调用）。

ex:学员报到。现在想为每一位新来报到的同学编学号(sid)，从第一名同学开始，sid为 1，以此类推。学号必须是唯一的，连续的，并且与班级的人数相符，这样以便知道，要分配给下一名新同学的学 号是多少。这样我们就需要一个变量，与单独的每一个学生对象无关，而是与整个班级同学数量有关。
所以，我们可以这样定义一个静态变量numberOfStudent，
```java
public class Student {
    //部分代码，省略了Getter/Setter
    private String name;
    private int age;
    static String room;
    private int id;
    private static int idCounter = 0;

    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
        this.id = ++idCounter;//自动创建学号，不需要赋值
    }
}
```
#### static修饰成员方法

static修饰的成员方法叫做静态方法。静态方法不属于对象，而是属于类。

非静态方法，必须首先创建对象，然后通过对象才能使用它。非静态方法可以访问静态和非静态变量，也可以调用静态方法和非静态方法。

静态方法，不需要创建对象，直接通过类名称就能使用它。静态方法只能访问静态变量和调用静态方法。

静态方法推荐使用类名称进行调用：类名称.静态方法()（虽然对象名也能调用，但编译的时候会被强制翻译成类名称调用。）。根据类名称访问静态变量时，全程和对象没有关系，只和类有关系。

对于本类中的静态方法，可以省略类名称：静态方法()。
注意事项：

（1）**静态方法不能直接访问非静态变量，也不能调用非静态方法**。因为在内存中是先有的静态内容，后有的非静态内容。

（2）**静态方法中不能使用this**。因为调用静态时，不是通过对象名调用，而是被强制翻译成类名称调用。不使用对象，而this代表当前对象，产生了矛盾。


#### 静态的存储

static修饰的内容:

是随着类的加载而加载的，且只加载一次。 

存储于一块固定的内存区域(静态区，位于方法区中)，所以，可以直接被类名调用。 

它优先于对象存在，所以，可以被所有对象共享。

#### 静态代码块

格式
```java
public class 类名称{
    static{
        //静态代码块的内容
    }
}
```
当第一次用到本类时，静态代码块执行唯一的一次。

静态内容总是优先于非静态，所以静态代码块比构造方法先执行。

静态代码块的典型用途：一次性对静态成员变量进行赋值。

```
public class Person {

    static {
        System.out.println("静态代码块执行！");
    }

    public Person() {
        System.out.println("构造方法执行！");
    }
}
```
```
public class Demo01StaticField {
    public static void main(String[] args) {
        Person one =new Person();//只有第一次使用该类时，静态代码块才执行。
        Person two =new Person();
    }
}
```
打印结果：
```
静态代码块执行
构造方法执行
构造方法执行
```

