- [继承](#继承)
- [super](#super)
- [this](#this)
- [](#)
- [](#)
- [](#)
- [](#)

### 继承

继承主要解决的问题是共性抽取。继承已存在的类就是复用这些类的方法和域。

父类也叫基类，超类;子类也叫派生类

继承关系的特点：

(1)子类可以拥有父类的内容。

(2)子类还可以拥有自己专有的内容。

- [继承的设计原则](#继承的设计原则)
- [继承的格式](#继承的格式)
- [区分子类中重名的三种变量](#区分子类中重名的三种变量)
- [继承中成员变量的的访问特点 ](#继承中成员变量的的访问特点 )
- [继承中成员方法的访问特点](#继承中成员方法的访问特点)
- [覆盖重写](#覆盖重写)
- [继承中构造方法的特点](#继承中构造方法的特点)

#### 继承的设计原则

对于已经投入使用的类，尽量不要进行修改。推荐定义一个新的类，重复利用其中共性内容，并且添加和覆盖重写新内容。

#### 继承的格式

在继承的关系中，子类就是父类。也就是说子类可以被当做父类看待。

定义父类的格式和普通类的定义没有区别。

定义子类的格式：
```
public class 子类名称 extends 父类名称{

}
```
#### 区分子类中重名的三种变量

父类的成员变量，子类的成员变量，子类方法中的局部变量，如果三者重名。

局部变量：直接写。

本类中的成员变量：this.变量名

父类的成员变量：super.变量名

#### 继承中成员变量的的访问特点 

在父子类的继承关系当中，如果成员变量重名（没有重名也是这个寻找顺序），则创建子类对象时，访问有两种方式:

(1)直接通过子类对象访问成员变量

直接通过子类对象访问成员变量：new创建子类对象时，等号左边是哪个类，就优先用谁，没有则向上找。
```
Fu objectName = new Zi();
zi.num;//创建子类对象时，如果左边是Fu类，就优先用Fu类里的成员变量num,如果没有这个变量就向上找。

Zi objectName = new Zi();
zi.num;//创建子类对象时，如果左边是Zi类，就优先用Zii类里的成员变量num,如果没有这个变量就向上找。
```
(2)间接通过成员方法访问成员变量

方法属于哪个类，就优先用哪个类的成员变量，没有则向上找。


#### 继承中成员方法的访问特点

在父子类的继承关系当中，如果成员方法重名（没有重名也是这个寻找顺序）：

创建的对象是那个类，就优先用哪个类的方法，如果没有就向上找。
```
Zi zi = new Zi();
zi.method();
右边new的是Z类，就优先用Zi类的method()方法。
```

无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类。

成员变量是从创建语句等号左边的类开始找，成员方法是从创建语句右边的类开始找。

#### 覆盖重写

重写(Override)：在继承关系当中，方法的名称一样，参数列表也一样。重写也叫覆盖，覆写。

重载(Overload)：方法的名称一样，参数列表不一样。

方法的覆盖重写特点：创建的是哪个类的对象，就优先用哪个类的方法，没有就向上找。

**注意事项**：

（1）必须保证父子类直接的方法名称相同，参数列表也相同。

@Override:这是一个注解，写在方法的前面，用来检测是不是正确的覆盖重写。这是一个可选的安全检测手段，建议能写就写。

（2）子类方法的返回值必须小于等于父类方法的返回值范围。

java.lang.Object类是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类。

void是一个不可实例化的类，无返回值。若父类方法返回值Object类，子类方法的返回值不能是void，因为一个有返回值一个无返回值。

（3）子类方法的权限必须大于等于父类方法的权限修饰符。

public>protected>(default)>private

default不是关键字，而是什么都不写，留空。

(4)覆盖重写时如果要保留父类方法中的功能：super.方法名();

```java
父类    
    public void show(){
        System.out.println("显示号码");
    }
```
```java
子类
    @Override
    public void show() {
        super.show();//保留父类方法中的功能
        System.out.println("显示姓名");
        System.out.println("显示头像");
    }
```

#### 继承中构造方法的特点

子类的构造方法必须要用super关键字，来调用父类的构造方法。而且子类的非构造方法无法调用父类构造方法，只有子类的构造方法才能调用父类的构造方法。

（1）子类构造方法中有一个默认隐含的"super()"调用，而且一定是先调用的父类构造，后执行的子类构造。如果父类中没有无参的构造方法，同时子类中没有调用父类重载构造，默认的super()调用就失败了，会报错。

（2）super的父类构造调用，必须是子类构造方法中的第一个语句。不能一个子类构造调用多次super构造，只能在第一个语句写调用一次。

总结：子类构造方法必须调用父类构造方法，不写则默认为super()；写了则用指定的super调用，super只能有一个，而且必须是构造方法的第一个语句。

### super

super关键字用来访问父类内容，主要有三种用法:

（1）在子类的成员方法中，访问父类的成员变量：super.父类成员变量名

（2）在子类的成员方法中，访问父类的成员方法：super.父类成员方法名

可以出现在子类成员方法中的任意位置。

（3）在子类的构造方法中，访问父类的构造方法：super(输入参数);

必须是子类的构造方法的第一个语句，只能调用一次。

子类构造方法的参数列表与父类构造方法的参数列表无关，可以任意定义。只是super里的参数，要和父类重载构造方法的参数类型一致。
```
父类   
    public Fu(int a) {
        System.out.println("父类构造方法");
    }
```
```
子类  
    public Zi() {
        super(10);
        System.out.println("子类构造方法");
    }
```

### this

this关键字用来访问本类内容，用法有三种：

（1）在本类的成员方法中，访问本类的成员变量：this.本类成员变量名

（2）在本类的成员方法中，访问本类的成员方法：this.本类成员方法名(可以访问其他成员方法，也可以递归调用自己)

（3）在本类的构造方法中，访问本类的另一个构造方法：this(参数)(构造方法不能自己调用自己)

构造方法中this()调用必须是第一个语句，且只能调用一次。

重载的构造方法之间，不能循环调用构造方法。
```
public class Zi extends Fu{
    int num = 0;
    public void method(){
        this.num=1;//在本类的成员方法中，访问本类的成员变量。
        this.method1();//在本类的成员方法中，访问本类的成员方法。
    }
    public void method1(){
    }

    public Zi(){
        this(12);//本类的无参构造，调用本类的有参构造
    }
    public Zi(int n){
        this(10,12);//调用本类两个参数的构造
    }
    }
    public Zi(int m, int n){
        super();//调用父类的无参构造
    }
}
```


**super和this两种构造调用，不能同时使用，因为他们各自都是唯一的，且必须是构造方法的第一个语句。**
