### 事务

事务就是多个DML语句捆绑在一起。一个事务是一个完整的业务逻辑单元，不可再分。

对于复杂的数据操作过程，往往需要一组SQL语句来完成，这就必须保证所有命令执行的同步性。而事务处理机制可以保证在同一个事务中的操作具有同步性。

事务的执行要么成功，要么返回到事务开始前的状态，这保证了同一事务操作的同步性和数据的完整性。

**注意**： 

（1）和事务相关的语句只有DML语句：insert delete update

因为他们这三个语句都是和数据库表当中的"数据"相关的。 事务的存在是为了保证数据的完整性，安全性。

创建或删除数据库，DDL语句和事务无关，且这些语句执行时会隐式的提交事务。

假设所有的业务都能使用1条DML语句搞定，还需要事务机制吗？

不需要事务机制。但实际情况不是这样的，通常一个"事儿(事务【业务】)"需要多条DML语句共同联合完成。

（2）MySQL中的事务不允许嵌套，若在执行START TRANSACTION语句前上一个事务还未提交，会隐式地提交上一个事务。

[事务的原理](#事务的原理)

[事务的特性](#事务的特性)

[事务的基本操作](#事务的基本操作)

[事务的保存点](#事务的保存点)

[事务隔离级别](#事务隔离级别)

[事务的访问模式](#事务的访问模式)

### 事务的原理

开启事务后，通过日志记录数据库的变化，把历史操作放入缓存中，不会真正修改数据库中的数据。提交事务时可以一次性修改文件。

提交事务或者回滚后事务结束，无论有没有提交事务，结束时缓存都会被清空。

### 事务的特性

事务有四大特性ACID

原子性：事务是最小的工作单元，不可分割。只有事务中所有数据库操作都执行成功，才算事务执行成功。否则已经执行成功的DML语句也必须撤销，数据库回滚到执行事务前的状态。

一致性：无论事务执行成功还是失败，都要保证数据库系统处于一致的状态，保证数据库系统不会返回到一个未处理的事务中。mysql的一致性主要由日志机制实现，通过日志记录数据库的所有变化，为事务恢复提供了跟踪记录。

隔离性：一个事务执行时，不会受到其他事务的影响。相关的技术有并发控制、锁、可串行化等。当多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰。

持久性：事务一旦被提交，其对数据库的修改就是永久性的。只能从事务本身的角度来保证永久性，外部原因如硬盘损坏会可能导致提交的数据丢失。

### 事务的基本操作

（1）开始事务和结束事务

默认情况下，用户执行的每一条SQL语句都会被当成单独的事务自动提交。

如果要将一组SQL作为一个事务，需要先开启事务，此时只有用户手动提交或取消事务，该事务才会结束。

```
START TRANSACTION; #显式开启事务

若干SQL语句

COMMIT [AND [NO] CHAIN] [[NO] RELEASE]; #提交事务，提交后当前事务结束，无法回滚

ROLLBACK [AND [NO] CHAIN] [[NO] RELEASE]; #回滚，即取消事务。只能针对未提交的事务回滚。

AND CHAIN用于在当前事务结束时，立即启动一个新的事务，且新事务与刚结束的事务有相同的隔离级别。NO表示抑制。

RELEASE用于在终止当前事务后，让服务器断开与客户端的连接。
```

（2）事务的自动提交

可以通过更改AUTOCOMMIT变量来设置事务是否自动提交，值为1表示开启自动提交，0表示关闭自动提交。

```
SELECT @@autocommit; #查看当前会话的AUTOCOMMIT值。

SET AUTOCOMMIT = 0; #设置AUTOCOMMIT变量的值。
```

### 事务的保存点

混滚时事务内所有的操作都将撤销，若希望只撤销一部分，可以用保存点来实现。

一个事务中可以创建多个保存点，在提交事务后事务中的保存点就会被删除。在回滚到某个保存点后，在该保存点之后创建过的保存点也会消失。

```
SAVEPOINT 保存点名;#设置保存点
ROLLBACK TO SAVEPOINT 保存点名; #回滚到指定保存点
RELEASE SAVEPOINT 保存点名; #删除不再需要的保存点
```

### 事务隔离级别

数据库是一个多用户的共享资源，MySQL允许多线程并发访问，因此用户可以通过不同的线程执行不同的事务。为了保证这些事物之间不受影响，对事务设置隔离级别是十分必要的。

Oracle数据库默认的隔离级别是：第二级别，读已提交。

mysql数据库默认的隔离级别是：第三级别，可重复读。

MySQL中的事务隔离级别有：READ UNCOMMITTED(读取未提交)、READ COMMITTED(读取提交)、REPEATABLE READ(可重复读)、SERIALIZABLE(可串行化)。

**READ UNCOMMITTED**：该级别下的事务可以读取到其他事务中未提交的数据，这种读取方式也叫脏读。脏读就是一个事务读取了另外一个事务未提交的数据。

**READ COMMITTED**：在该隔离级别下只能读取其他事务已经提交的数据，避免了脏读数据的现象。但该隔离级别会出现不可重复读的问题。不可重复读是指在一个事务中多次查询的结果不一致，原因是查询的过程中数据发生了改变。

**REPEATABLE READ**：解决了脏读和不可重复读的问题，该隔离级别可能会出现幻读现象。幻读是指在一个事务中两次查询的记录数不一样。MySQL的InnoDB引擎通过多版本并发控制机制解决了幻读的问题。

幻读举例：

```
（1）事务A查询了表t1，事务B插入了一条数据但未提交。
（2）事务A第二次查询表t1，和第一次的结果一样。
（3）事务B提交了事务，事务A第三次查询表t1，和第一次的结果一样。
（4）事务A更新表中的某个字段的值，事务A第四次查询表t1，会多出事务B插入的那条数据。
```

**SERIALIZABLE**：在每个读的的数据行上加锁，使之不会发生冲突，从而解决了脏读、不可重复读和幻读的问题。但加锁可能导致超时和锁竞争，因此SERIALIZABLE也是性能最低的隔离级别。除非为了数据的稳定性，需要强制减少并发的情况时，才会选择此种隔离级别。

如果一个事务使用了SERIALIZABLE隔离级别，在这个事务没有被提交前，其他会话只能等到当前操作完成后，才能进行操作，这样会影响数据库的并发性能。

（1）查看隔离级别

```
select @@global.transaction_isolation; #查看全局隔离级别
select @@session.transaction_isolation; #查看当前会话中的隔离级别
select @@transaction_isolation; #查看下一个事务的隔离级别，仅对当前用户的下一个事务操作有影响。
```

（2）修改隔离级别

```
SET [SESSION | GLOBAL] TRANSACTION LEVEL 参数值; 
#若省略SESSION或GLOBAL，表示设置下一个事务的蛤蜊级别
#参数值可以是READ UNCOMMITTED,READ COMMITTED,REPEATABLEREAD,SERIALIZABLE。
```

### 事务的访问模式

默认情况下，事务的访问模式为

READ WRITE(读/写模式)，表示事务可以执行读写操作，若开发需要可以将事务的访问模式设置为READ ONLY(只读模式)，禁止对表进行修改。

```
SET [SESSION | GLOBAL] TRANSACTION READ ONLY; 
SET [SESSION | GLOBAL] TRANSACTION READ WRITE;
```
