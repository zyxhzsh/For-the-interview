1.什么是MySQL

2.存储引擎

3.字符集及校对规则

4.索引

5.查询缓存

6.事务

7.锁机制与InnoDB锁算法

8.大表优化

9.解释一下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?

10.分库分表之后,id主键如何处理?

11.一条SQL语句在MySQL中如何执行的

12.MySQL高性能优化规范建议

13.一条SQL语句执行得很慢的原因有哪些?

14.书写高质量SQL的30条建议

1.什么是MySQL

MySQL是一种开源的关系型数据库，并且方便扩展。MySQL的默认端口号是3306。

2.存储引擎

存储引擎就是表的存储方式。不同的存储引擎会有不同的存储方式。存储引擎这个名字只在mysql中存在，别的数据库不叫这个名字。mysql支持很多存储引擎，每个存储引擎都对应了一种不同的存储方式。每一个存储引擎都有自己的优缺点，需要在合适的时机选择合适的存储引擎。

5.5版之后MySQL默认的存储引擎是InnoDB,之前默认引擎是MyISAM。
 ```
 mysql> show variables like '%storage_engine%';#查看默认的存储引擎
 mysql> show table status like "table_name";#查看表的存储引擎
 ```

MyISAM提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。大多数时候我们使用的都是InnoDB存储引擎，但是在某些情况下使用MyISAM也是合适的，比如读密集的情况下。

MyISAM和InnoDB对比：
```
是否支持行级锁 : MyISAM只有表级锁(table-level locking)，而InnoDB支持行级锁(row- level locking)和表级锁,默认为行级锁。

是否支持事务和崩溃后的安全恢复: MyISAM强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。InnoDB提供事务支持，具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。

是否支持外键: MyISAM不支持，而InnoDB支持。

是否支持MVCC :仅InnoDB支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在READ COMMITTED和REPEATABLE READ两个隔离级别下工作;MVCC可以使用乐观(optimistic)锁 和悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。

 MyISAM可被压缩，节省存储空间。可以转换为只读表，提高检索效率；InnoDB数据存储在tablespace这样的表空间中(逻辑概念)，无法被压缩，无法转换成只读。
```

不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB的速度都可以让MyISAM望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。

一般情况下我们选择InnoDB都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择MyISAM也是一个不错的选 择。

MEMORY：以前叫做HEPA引擎。不支持事务，不支持回滚。数据容易丢失。因为所有数据和索引都是存储在内存当中的，断电就没了。优点：查询速度最快。它支持表级索引，不能包含TEXT或BLOB字段，因为内存存储不了。

3.字符集及校对规则

字符集指的是一种从二进制编码到某类字符符号的映射。校对规则则是指某种字符集下的排序规则。MySQL中每一种字符集都会对应一系列的校对规则。

MySQL采用的是类似继承的方式指定字符集的默认值，每个数据库以及每张数据表都有自己的默认值，他们逐层继承。比如:某个库中所有表的默认字符集将是该数据库所指定的字符集。

4.索引

MySQL索引使用的数据结构主要有BTree索引和哈希索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最 快;其余大部分场景，建议选择BTree索引。

MySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。

MyISAM: B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的 值为地址读取相应的数据记录。这被称为“非聚簇索引”。

InnoDB: 其数据文件本身就是索引文件，表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引(或聚集索引)”。而其余的索引都作为􏰅辅助索引，􏰅辅助索引的data域存储相应记录主键的值而不是地址。在根据主索引搜索时，直接找到key所 在的节点即可取出数据;在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过⻓的字段作为主键，也不建议使用非单调的字段 作为主键，这样会造成主索引频繁分裂。

（1）能说说什么是索引吗？索引的种类有哪些？

索引是帮助数据库高效获取数据的数据结构。索引是基于数据库表创建的，它包含一个表中某些列的值以及记录对应的地址，并且把这些值存储在一个数据结构中。最常见的就是使用哈希表、B+树作为索引，项目中我们使用InnoDB引擎，默认的是B+树。

（2）什么情况适合建索引？

一般来说，在WHERE和JOIN中出现的列需要建立索引，因为MYSQL只对<,<=,=,>,>=,BETWEEN,IN,以及某些时候的LIKE才会使用索引（以通配符%和_开头做查询时，MYSQL不会使用索引）。通常会根据慢查询日志来优化SQL以及判断是否建立索引。

（3）在创建索引的时候会考虑哪些因素？

在日常工作中，我们会开慢查询去记录一些执行时间比较久的SQL语句,慢查询的阈值是500ms，找出这些SQL语句后，我们用到explain命令来查看这些SQL语句的执行计划，查看该SQL语句有没有使用上索引，有没有做全表扫描，把查询条件中没有建立索引的列创建索引。

（4）在创建联合索引的时候，你是怎样考虑多个字段之间的顺序的？

在创建联合索引的时候，根据业务的需求，where子句中使用最频繁的一列放在最左边，因为MySQL索引查询会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配，所以当我们创建了一个联合索引时，如(key1,key2,key3),相当于创建了(key1),(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则。

（5）为什么使用B+树实现索引？

由于索引是存在磁盘中，当索引非常大时，无法一次加载到内存中。所以数据库中索引使用的是查询效率较高的树形结构。B+树是平衡多路查找树，是为磁盘等外存设备设计的一种平衡查找树。

如果二叉树变成退化成链表，查询效率就非常的低。为了解决这样一个问题，就需要确保二叉树一直是平衡的：每个节点的左右子树的高度差不能超过1。插入或删除数据时导致不满足平衡时，平衡二叉树就会对节点进行调整来保持平衡。

如果能尽可能多的把数据放在一个磁盘块中，一次磁盘的读取操作就能读取更多的数据。但平衡二叉树每一个节点只存储一个键值和数据，系统从磁盘读取数据到内存时是以磁盘块为基本单位的，也就是说每个磁盘块仅仅存储一个键值和数据。如果存储海量的数据，二叉树的节点会非常多，高度也会非常高。这样在查找数据时会进行很多次的磁盘IO，效率极低。

因此需要找到一种单个节点可以存储多个键值和数据的平衡二叉树。

B树相比平衡二叉树，每一个节点存储了更多的键值和数据，并且每个节点拥有更多的子节点，一个节点能连接的子节点的个数称为阶。B树的高度也会比较低，在查找数据时读取磁盘的次数就大大减少了，查找效率比平衡二叉树高很多。

B树与B+s树的区别：B+树的非叶子节点是不存储数据的，只存储键值。而B树节点的非叶子节点不仅存储键值，同时也存储数据。数据库中的页的大小是固定的，如果不存储数据，就能够存储更多的键值，相应树的阶数就会更大，树的高度就会更低。这样查找数据进行磁盘IO的次数会再次减少。根节点存储在内存中。

用B+树进行范围查找，分组查找，排列查找以及去重查找会非常简单。而B树因为数据分散在各个节点，要实现这些相对要困难很多。

B树的数据页之间通过双向链表连接（非叶子节点）。

（6）B+树的优点

系统从磁盘读取数据到内存时是以磁盘块为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来。InnoDB中以页作为磁盘管理的最小单位，页的默认大小为16KB，可以通过参数innodb_page_size设置页的大小，InnoDB在把磁盘数据读入到内存时会以页为基本单位，（也就是尽可能多的把数据放在一个磁盘块中，一次磁盘的读取操作就能读取更多的数据）在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O的次数，提高查询效率。B树能够提高磁盘IO的性能，但是没有解决元素遍历效率低下的问题。

B+树使用有序数组链表+平衡多叉树改良了B树的有序数组+平衡多叉树；B+树的关键字全部存放在叶子节点中，非叶子节点用户做索引，而叶子节点中有一个指针指向下一个叶子节点。做这个优化的目的是为了提高区间访问的性能。B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，也是B+树的优势所在。

例如要查询5-10之间的数据，B+树只需要找到5和10，然后串起来就可以了。而B树在找到5后，得遍历B树获取下一个块.直到遇到一个不符合条件的关键字。遍历的过程是比较复杂的。

（7）B+树和Hash索引相比有什么优缺点吗？

哈希表适合等值查询，但是无法进行范围查询。

哈希索引没办法利用索引完成排序，不支持多列联合查询的最左匹配规则。

如果有大量重复键值，哈希索引的效率会很低，

（8）B+树的叶子节点可以存哪些东西？

InnoDB的B+树可能存储的是整行数据，也可能是主键的值。存储了整行数据的是主键索引，也被称为聚簇索引。存储了主键的值的是非主键索引，也称为非聚簇索引。

（9）聚簇索引和非聚簇索引在查询数据的时候有什么区别？

主键索引查询只会查一次，而非主键索引需要回表查询多次，通过覆盖索引也可以只查询一次。覆盖索引指一个查询语句被索引覆盖，查询的数据列只用从索引中就能够取得，不必从数据表中读取。

聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。聚簇索引的顺序，就是数据在硬盘上的物理顺序。一般情况下主键就是默认的聚簇索引。

一张表只允许存在一个聚簇索引，因为真实数据的物理顺序只能有一种。如果一张表上还没有聚簇索引，为它新创建聚簇索引时，就需要对已有数据重新进行排序，所以对表进行修改速度较慢是聚簇索引的缺点，对于经常更新的列不宜建立聚簇索引。

聚簇索引性能最好，因为一旦具有第一个索引值的记录被找到，具有连续索引值的记录也一定物理地紧跟其后。聚簇索引默认是主键，如果表中没有定义主键，InnoDB[1]会选择一个唯一的非空索引代替，如果没有这样的索引，InnoDB会隐式地定义一个主键来作为聚簇索引。

5.查询缓存

执行查询语句的时候，会先查询缓存，如果命中则直接返回结果，如果没有命中就通过SQL语句查询数据。

如果查询中包含任何用户自定 义函数、存储函数、用户变量、临时表、MySQL库中的系统表，其查询结果也不会被缓存。

缓存建立之后，MySQL的查询缓存系统会跟踪查询中涉及的每张表，如果这些表(数据或结构) 发生变化，那么和这张表相关的所有缓存数据都将失效。

开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。因 此任何两个查询在任何字符上的不同都会导致缓存不命中。

缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。 

开启缓存查询要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十MB比􏰀合适。此外，还可以通过sql_cache和sql_no_cache来控制某个查询语句是否需要缓存。

6.事务

事务就是多个DML语句捆绑在一起。一个事务是一个完整的业务逻辑单元，不可再分。最经典的例子就是转账，将小明的余额减少1000元，将小红的余额增加1000元，事务就是保证这两个关键操作要么都成功，要么都要失败。

（1）事物的四大特性

原子性(Atomicity): 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么 全部完成，要么完全不起作用;

一致性(Consistency): 执行事务前后，数据保持一致，多个事务对同一个数据读取的结 果是相同的;

隔离性(Isolation): 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发 事务之间数据库是独立的;

持久性(Durability): 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数 据库发生故障也不应该对其有任何影响。

（2）并发事务带来哪些问题

在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务，可能会导致以下的问题。

脏读(Dirty read): 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据 是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。

丢失修改(Lost to modify): 指在一个事务读取一个数据时，另外一个事务也访问了该数 据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事 务内的修改结果就被丢失，因此称为丢失修改。 例如:事务1读取某表中的数据A=20，事 务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。

不可重复读(Unrepeatableread): 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事 务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。

幻读(Phantom read): 在一个事务中两次查询的记录数不一样。例如一个事务(T1)读取了几行数据，接着另一个并发事务(T2)插入了一些数据。在第二次进行相同的查询时，第一个事务(T1) 就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

不可重复读和幻读区别:不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改；幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。

（3）事务隔离级别有哪些?MySQL的默认隔离级别是?

READ UNCOMMITTED：该级别下的事务可以读取到其他事务中未提交的数据。可能会导致脏读、幻读或不可重复读。

READ COMMITTED：在该隔离级别下只能读取其他事务已经提交的数据，避免了脏读数据的现象，但是幻读或不可重复读仍有可能发生。

REPEATABLE READ: 对同一字段的多次读取结果都是一致的，除非数据是被该事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。MySQL的InnoDB引擎通过多版本并发控制机制解决了幻读的问题。

SERIALIZABLE(可串行化): 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可 重复读以及幻读。

MySQL InnoDB存储引擎默认支持的隔离级别是REPEATABLE READ（可通过命令查看SELECT @@tx_isolation;）

与SQL标准不同的地方在于InnoDB存储引擎在REPEATABLE READ事务隔离级别下使用的是Next-Key Lock锁算法，因此可以避免幻读的产生，这与其他数据库系统(如SQL Server)是不同的。所以说InnoDB存储引擎默认支持的隔离级别是REPEATABLE READ(可重读)已经可以完全保证事务的隔离性要求，即达到了SQL标准的SERIALIZABLE(可串行化) 隔离级别。

因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED。但InnoDB存储引擎默认使用REPEATABLE READ并不会有任何性能损失。

InnoDB存储引擎在分布式事务的情况下一般会用到SERIALIZABLE(可串行化)隔离级别。

7.锁机制与InnoDB锁算法

可以按照锁的粒度把数据库锁分为表级锁和行级锁。

MyISAM采用表级锁(table-level locking)。

InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁。

（1）表级锁和行级锁对比

表级锁: MySQL中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单，资源消 耗也比􏰀少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最 低，MyISAM和 InnoDB引擎都支持表级锁。

行级锁: MySQL中锁定粒度最小的一种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会 出现死锁。

虽然使用行级索具有粒度小、并发度高等特点，但是表级锁有时候也是非常必要的：事务更新大表中的大部分数据直接使用表级锁效率更高；事务比较复杂，使用行级索很可能引起死锁导致回滚。

（2）InnoDB支持的行级锁，包括如下几种：
```
Record Lock: 对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；
Gap Lock: 对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。
Next-key Lock：锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题。
```
（3）按照是否可写分类

表级锁和行级锁可以进一步划分为共享锁（s）和排他锁（X）。

共享锁又被称为读锁，若事务T对数据对象A加上共享锁，其他事务只能对A再加共享锁，不能加排他锁，直到已释放所有共享锁。

排它锁又称为写锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。在更新操作(INSERT、UPDATE 或 DELETE)过程中始终应用排它锁。

（4）InnoDB死锁

在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，这就决定了在InnoDB中发生死锁是可能的。

发生死锁后，InnoDB一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB并不能完全自动检测到死锁，这需要通过设置锁等待超时参数innodb_lock_wait_timeout来解决。

这个参数并不是只用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获得所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖跨数据库。我们通过设置合适的锁等待超时阈值，可以避免这种情况发生。

（5）相关知识点
```
innodb对于行的查询使用next-key lock

Next-key lock为解决幻读问题。

当查询的索引含有唯一属性时，将next-key lock降级为record key

Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，这会导致幻读问题

有两种方式显式关闭gap锁：将事务隔离级别设置为RC；将参数innodb_locks_unsafe_for_binlog设置为1
```

8.大表优化

当MySQL单表记录数过大时，数据库的CRUD性能会明显下降。常⻅的优化措施：

（1）限定数据的范围

禁止不带任何限制数据范围条件的查询语句。

（2）读写分离

主库负责写，从库负责读

（3）垂直分区

垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 

根据数据库里面数据表的相关性进行拆分。例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。

垂直拆分的优点: 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。

垂直拆分的缺点: 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂;

（4）水平分区

保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。水平拆分可以支撑非常大的数据量。

水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张表的数据拆成多张表来存放。举个例子:我们可以将用户信息表拆分成多个用户信息表，这样就可以避 免单一表数据量过大对性能造成影响。

注意：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以水平拆分最好分库 。

水平拆分能够支持非常大的数据量存储，应用端改造也少，但分片事务难以解决，跨节点Join性能􏰀差，逻辑复杂。

尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。

数据库分片的两种常⻅方案:

```
客户端代理: 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的 Sharding-JDBC 、阿里的TDDL是两种比􏰀常用的实现。

中间件代理: 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。
```

9.解释一下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?

这种设计会初始预设资源，解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销等。

除了初始化资源，池化设计还包括如下这些特征：池子的初始值、池子的活跃值、池子的最大值等，这些特征可以直接映射到java线程池和数据库连接池的成员属性中。

数据库连接本质就是一个 socket 的连接。数据库服务端还要维护一些缓存和用户权限信息之类的所以占用了一些内存。

可以把数据库连接池是看做是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以重用这些连接。

为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序的请求，既昂贵又浪费资源。在连接池中，创建连接后，将其放置在池 中，并再次使用它，因此不必建立新的连接。如果使用了所有连接，则会建立一个新连接并将其 添加到池中。 连接池还减少了用户必须等待建立与数据库的连接的时间。

10.分库分表之后,id主键如何处理?

分成多个表之后，需要一个全局唯一的id来支持。

生成全局id有下面这几种方式:

UUID(通用唯一识别码): 不适合作为主键，因为太⻓了，并且无序不可读，查询效率低。比􏰀较适合用于生成唯一的名字的标示比如文件的名字。

数据库自增id: 两台数据库分别设置不同步⻓，生成不重复ID的策略来实现高可用。这种方式生成的id有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。

利用redis生成id : 性能比􏰀好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。

Twitter的snowflake算法

11.一条SQL语句在MySQL中如何执行的

MySQL基本架构概览

MySQL主要分为Server层和存储引擎层：

Server 层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。

存储引擎：主要负责数据的存储和读取，采用可以替换的插件式架构。MySQL自带的日志模块式binlog，所有的存储引擎都可以使用。InnoDB引擎自带了一个日志模块redolog。

```
连接器：身份认证和权限相关(登录MySQL的时候)。
查询缓存：执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。
分析器：没有命中缓存的话，SQL语句就会经过分析器，分析器说白了就是要先看你的SQL语句要干嘛，再检查你的SQL语句语法是否正确。
优化器：按照MySQL认为最优的方案去执行。
执行器：执行语句，然后从存储引擎返回数据。
```

查询语句：

先检查该语句是否有权限，开启了查询缓存就会去缓存中查询，如果缓存中没有，执行下一步。

然后通过分析器进行词法分析，判断这个语句是否有语法错误。没有问题就执行下一步。

接下来就是优化器确定执行方案，优化器根据自己的优化算法选择执行效率最好的一个方案。

进行权限校验，如果没有权限就会返回错误信息，如果有权限执行器就会调用数据库引擎接口，返回引擎的执行结果。

更新语句：

分析器权限校验

执行器调用引擎接口完成更新。

InnoDB引擎把数据保存在内存中，同时记录redo log，此时redo log进入prepare状态，然后告诉执行器，执行完成了，随时可以提交。

执行器收到通知后记录binlog，然后调用引擎接口，提交redo log为提交状态。

更新完成

InnoDB引擎就是通过redo log来支持事务的。采用redo log两阶段提交的方式，能够保证数据的一致性。

假设redo log处于预提交状态，binglog也已经写完了，这个时候发生了异常重启会怎么样呢？这个就要依赖于 MySQL 的处理机制了，MySQL的处理过程如下：

判断redo log是否完整，如果判断是完整的，就立即提交。

如果redo log只是预提交但不是commit 状态，这个时候就会去判断binlog是否完整，如果完整就提交redo log,不完整就回滚事务。

12.MySQL高性能优化规范建议

（1）数据库命令规范

所有数据库对象名称必须使用小写字母并用下划线分割，并且最好不要超过32个字符。

所有数据库对象名称禁止使用MySQL保留关键字。

临时库表必须以tmp_为前缀并以日期为后缀，备份表必须以bak_为前缀并以日期(时间戳)为后缀。

所有存储相同数据的列名和列类型必须一致。（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）

（2）数据库基本设计规范

没有特殊要求的情况下，所有表必须使用Innodb存储引擎。

数据库和表的字符集统一使用UTF8。

所有表和字段都需要添加注释

尽量控制单表数据量的大小,建议控制在500万以内。(过大会造成修改表结构，备份，恢复都会有很大的问题。)

可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小。

谨慎使用MySQL分区表，跨分区查询效率可能更低。建议采用物理分表的方式管理大数据。

尽量做到冷热数据分离,减小表的宽度

禁止在表中建立预留字段

禁止在数据库中存储图片,文件等大的二进制数据

（3）数据库字段设计规范

优先选择符合存储需要的最小的数据类型（列的字段越大，建立索引时所需要的空间也就越大，一页中所能存储的索引节点的数量也就越少）将字符串转换成数字类型存储,如:将 IP 地址转换成整形数据；对于非负型的数据 (如自增 ID,整型 IP) 来说,要优先使用无符号整型来存储。

避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据。建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，TEXT 或 BLOB 类型只能使用前缀索引。

避免使用 ENUM 类型。修改ENUM值需要使用ALTER语句，ENUM类型的ORDER BY操作效率低，需要额外操作，禁止使用数值作为ENUM的枚举值。

尽可能把所有列定义为 NOT NULL，索引NULL列需要额外的空间来保存，进行比较和计算时要对NULL值做特别的处理。

使用TIMESTAMP(4个字节)或DATETIME类型 (8个字节) 存储时间。如果用字符串存储日期类型，无法用日期函数进行计算和比较，用字符串存储日期要占用更多的空间。

同财务相关的金额类数据必须使用decimal类型，Decimal类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节，可用于存储比bigint更大的整型数据。

（4）索引设计规范

限制每张表上的索引数量,建议单张表索引不超过5个。索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。如果同时有很多个索引都可以用于查询，就会增加MySQL优化器生成执行计划的时间。

禁止给表中的每一列都建立单独的索引，虽然有合并索引的优化方式，但远远没有使用一个联合索引的查询方式好。

每个Innodb表必须有个主键

常见索引列建议：出现在 SELECT、UPDATE、DELETE 语句的WHERE从句中的列，包含在ORDER BY、GROUP BY、DISTINCT中的字段，多表join的关联列。

如何选择索引列的顺序：区分度最高的放在联合索引的最左侧（列中不同值的数量/列的总行数），尽量把字段长度小的列放在联合索引的最左侧，使用最频繁的列放到联合索引的左侧。

避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）

对于频繁的查询优先考虑使用覆盖索引（包含了所有查询字段的索引）。优点是避免Innodb表进行索引的二次查询；可以把随机IO变成顺序IO加快查询效率（覆盖索引是按键值的顺序存储的，可以把磁盘的随机读取IO转变成索引查找的顺序IO）。

索引SET规范：尽量避免使用外键约束（外键会影响父表和子表的写操作从而降低性能）。

（5）数据库SQL开发规范

建议使用预编译语句进行数据库操作（预处理语句PreparedStatement会将传入的SQL命令封装在PreparedStatement对象中，事先进行预编译处理等待使用。）

避免数据类型的隐式转换。隐式转换会导致索引失效。

充分利用表上已经存在的索引

程序连接不同的数据库使用不同的账号，进制跨库查询

禁止使用SELECT\*必须使用SELECT<字段列表>查询（\*无法使用覆盖索引）

禁止使用不含字段列表的INSERT语句

尽量避免使用子查询(子查询在in子句中，且子查询中为简单SQL时，才可以把子查询转化为关联查询进行优化。)子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引。

避免使用JOIN关联太多的表。对于MySQL来说，是存在关联缓存的，缓存的大小可以由join_buffer_size参数进行设置。在MySQL中，对于同一个SQL多关联（join）一个表，就会多分配一个关联缓存，如果在一个SQL中关联的表越多，所占用的内存也就越大。如果程序中大量的使用了多表关联的操作，同时 join_buffer_size设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。

减少同数据库的交互次数

对应同一列进行or判断时，使用in代替or（in操作可以更有效的利用索引，or大多数情况下很少能利用到索引。）

禁止使用 order by rand() 进行随机排序。推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。

WHERE从句中禁止对列进行函数转换和计算（会导致无法使用索引）

在明显不会有重复值时使用UNION ALL而不是UNION，UNION会把两个结果集的所有数据放到临时表中后再进行去重操作，UNION ALL不会再对结果集进行去重操作。

拆分复杂的大SQL为多个小SQL。MySQL中，一个SQL只能使用一个CPU进行计算，SQL拆分后可以通过并行执行来提高处理效率。

13.一条SQL语句执行得很慢的原因有哪些?

一个 SQL 执行的很慢，我们要分两种情况讨论：

1、大多数情况下很正常，偶尔很慢，则有如下原因

(1)、数据库在刷新脏页，例如redo log写满了需要同步到磁盘。

(2)、执行的时候，遇到锁，如表锁、行锁。

2、这条SQL语句一直执行的很慢，则有如下原因。

(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。

(2)、数据库选错了索引。系统是通过索引的区分度来判断的，但不会遍历全部来获得一个索引的基数的。索引系统是通过遍历部分数据，也就是通过采样的方式，来预测索引的基数的。采样就有可能失误，导致系统不走索引直接走全表扫描。

14.书写高质量SQL的30条建议

[link](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486461&idx=1&sn=60a22279196d084cc398936fe3b37772&chksm=cea24436f9d5cd20a4fa0e907590f3e700d7378b3f608d7b33bb52cfb96f503b7ccb65a1deed&token=1987003517&lang=zh_CN%23rd)

查询SQL尽量不要使用select\*，而是select具体字段。select\*进行查询时，很可能就不会使用到覆盖索引了，就会造成回表查询。

如果知道查询结果只有一条或者只要最大/最小一条记录，建议用limit 1。加上limit 1后,只要找到了对应的一条记录,就不会继续向下扫描了,效率将会大大提高。当然，如果查询的字段是唯一索引的话，是不必要加上limit 1了。因为limit的存在主要就是为了防止全表扫描，从而提高性能,如果一个语句本身可以预知不用全表扫描，有没有limit ，性能的差别并不大。

应尽量避免在where子句中使用or来连接条件。使用or可能会使索引失效，从而全表扫描。
```
select * fromuserwhere userid=1or age =18
对于or+没有索引的age这种情况，假设它走了userId的索引，但是走到age查询条件时，它还得全表扫描，也就是需要三步过程：全表扫描+索引扫描+合并 如果它一开始就走全表扫描，直接一遍扫描就完事。mysql是有优化器的，处于效率与成本考虑，遇到or条件，索引可能失效，看起来也合情合理。
```
