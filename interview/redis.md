1.简单介绍一下Redis

2.Redis和Memcached的区别和共同点

3.缓存数据的处理流程是怎样的?

4.为什么要用Redis/为什么要用缓存?

5.Redis常⻅数据结构

6.Redis单线程模型

7.Redis为什么不用多线程

8.Redis6.0之后为何引入了多线程

9.Redis给缓存数据设置过期时间有啥用

10.Redis是如何判断数据是否过期的呢

11.过期的数据删除策略了解么

12.Redis内存淘汰机制了解么

13.Redis持久化机制

14.redis事务

15.缓存穿透

16.缓存雪崩

17.如何保证缓存和数据库数据的一致性

18.跳表、数据和链表的区别

19.redis持久化的方式

20.redis实现加锁的方式

21.本地缓存和redis的区别

1.简单介绍一下Redis

Redis是一个用C语言开发的内存数据库，读写速度非常快，被广泛用于实现缓存。Redis也经常用来做分布式锁，甚至是消息队列。

Redis提供了多种数据类型来支持不同的业务场景。Redis还支持事务、持久化、Lua脚本、多种集群方案。

2.Redis和Memcached的区别和共同点

分布式缓存主要解决的是单机缓存的容量受服务器限制并且无法保存通用的信息。因为，本地缓存只在当前服务里有效，比如如果你部署了两个相同的服务，他们两者之间的缓存数据是无法共通的。

共同点

（1）都是基于内存的数据库，一般都用来当做缓存使用。 

（2）都有过期策略。

（3）两者的性能都非常高。

区别

（1）Redis支持更丰富的数据类型(支持更复杂的应用场景)。Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。Memcached只支持最简 单的k/v数据类型。

（2）Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。

（3）Redis在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached在服务器内存使用完之后，就会直接报异常。

（4）Memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据;但是Redis目前是原生支持cluster模式的。

（5）Memcached是多线程非阻塞IO复用的网络模型;Redis使用单线程的多路IO复用模型。(Redis6.0引入了多线程IO) 

（6）Redis支持发布订阅模型、Lua 脚本、事务等功能，而Memcached不支持。并且，Redis支持更多的编程语言。

（7）Memcached过期数据的删除策略只用了惰性删除，而Redis同时使用了惰性删除与定期删除。

3.缓存数据的处理流程是怎样的?

如果用户请求的数据在缓存中就直接返回。

缓存中不存在的话就看数据库中是否存在，数据库中存在的话就更新缓存中的数据，然后返回数据；数据库中不存在的话就返回空数据。

4.为什么要用Redis/为什么要用缓存?

使用缓存主要是为了提升用户体验以及应对更多的用户。

高性能的角度：假如用户第一次访问数据库中的某些数据的话，这个过程是比􏰀慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。用户下一次再访问这些数据的时候就可以直接从缓存中获取了，速度相当快。

注意，要保持数据库和缓存中的数据的一致性。如果数据库中的对应数据改变了之后，同步改变缓存中相应的数据即可。


高并发的角度：一般像MySQL这类的数据库的QPS大概都在1w左右(4核8g) ，但是使用Redis缓存之后很容易达到10w+，甚至最高能达到30w+。(就单机 redis 的情况，redis 集群的话会更高)。

直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过 数据库。进而，我们也就提高的系统整体的并发。

QPS：服务器每秒可以执行的查询次数

5.Redis常⻅数据结构

（1）string

string数据结构是简单的key-value类型，redis构建了一种简单动态字符串(SDS)，不光可以保存文本数据还可以保存二进制数据，获取字符串⻓度的复杂度为O(1)。Redis的SDS API 是安全的，不会造成缓冲区溢出。

应用场景:一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。

常用命令: set,get,strlen,exists,dect,incr,setex等等
```
set key value #设置 key-value 类型的值

get key # 根据 key 获得对应的 value，若key不存在返回nil

exists key # 判断某个 key 是否存在，存在返回1，不存在返回0

strlen key # 返回key所储存的字符串值的⻓度。

del key # 删除某个 key 对应的值

批量设置

mset key1 value1 key2 value2 # 批量设置key-value 类型的值
mget key1 key2 # 批量获取多个key对应的value

计数器(字符串的内容为整数的时候可以使用)

set number 1
incr number # 将 key 中储存的数字值增一
decr number # 将 key 中储存的数字值减一

过期

expire key 60 # 数据在 60s 后过期

setex key 60 value # 设置key-value 类型的值，同时设置数据在60s后过期

ttl key # 查看数据还有多久过期
```

（2）list

易于数据元素的插入和删除并且且可以灵活调整链表⻓度，但是链表的随机访问困难。Redis的list实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。

应用场景: 发布与订阅或者消息队列、慢查询。

常用命令: rpush,rpop,lpush,lpop,lrange􏰁,llen等。通过lrange命令，你可以基于list实现分⻚查询，性能非常高。通过llen myList查看链表⻓度。

通过rpush/lpop实现队列:
```
rpush myList value1 #向list的右边添加元素

rpush myList value2 value3 #向list的右边添加多个元素

lpop myList # 将list的最左边元素取出

lrange myList start end # 查看对应下标的list列表
lrange myList 0 -1 # 查看列表中的所有元素，-1表示倒数第一
```

通过rpush/rpop实现栈
```
rpush myList2 value1 value2 value3

rpop myList2 #将list右边的元素取出
```

（3）hash

hash类似于JDK1.8前的HashMap，内部实现也差不多(数组 + 链表)。hash是一个string类型的field和value的映射表，特别适合用于存储对象。后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 

应用场景: 系统中对象数据的存储。

常用命令: hset,hmset,hexists,hget,hgetall,hkeys,hvals等。

```
hset userInfoKey name "guide" description "dev" age "24"

hexists userInfoKey name # 查看 key 对应的 value中指定的字段是否存在。

hget userInfoKey name # 获取key中指定字段的值。

hgetall userInfoKey # 获取指定key的所有字段和值。

hkeys userInfoKey # 获取 key 列表

hvals userInfoKey # 获取 value 列表

hset userInfoKey name "GuideGeGe" # 修改某个字段对应的值
```

（4）set

Redis中的set类型是一种无序集合，集合中的元素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口。可以基于set轻易实现交集、并集、差集的操作。比如:你可以将一个用户所 有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共 同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。

应用场景: 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景。

常用命令: sadd,spop,smembers,sismember,scard,sinterstore,sunion等。
```
sadd mySet value1 value2 # 添加元素进去

spop mySet [count] #随机删除count个元素，默认为1。

smembers mySet # 查看set中所有的元素

sismember mySet value1 # 检查某个元素是否存在set 中，只能接收单个元素

scard mySet # 查看set的⻓度

sadd mySet2 value2 value3

sinterstore mySet3 mySet mySet2 # 获取 mySet 和 mySet2 的交集并 存放在 mySet3 中，不加store就不会存
```

（5）sorted set

和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列，还可以通过score的范围来获取元素的列表

应用场景: 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息(可以理解为按消息维度的消息排行 榜)等信息。

常用命令: zadd,zcard,zscore,zrange,zrevrange,zrem 等。

```
zadd myZset 3.0 value1 # 添加元素到 sorted set 中 3.0 为权重

zadd myZset 2.0 value2 1.0 value3 # 一次添加多个元素

zcard myZset # 查看 sorted set 中的元素数量

 zrange myZset start end # 顺序输出某个范围区间的元素，0 -1表示输出所有元素

 zrevrange myZset start end # 逆序输出某个范围区间的元素
```

6.Redis单线程模型

Redis基于Reactor模式来设计开发了自己的一套高效的事件处理模型，这套事件处理模型对应的是Redis中的文件事件处理器。由于文件事件处理器(file event handler)是单线程 方式运行的，所以我们一般都说Redis是单线程模型。

Redis通过IO多路复用程序来监听来自客户端的大量连接(或者说是监听多个socket)，它会将感兴趣的事件及类型(读、写)注册到内核中并监听每个事件是否发生。 I/O 多路复用技术的使用让Redis不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗。

另外，Redis服务器是一个事件驱动程序，服务器需要处理两类事件: 1.文件事件;2.时间事件。

文件事件处理器使用I/O多路复用(multiplexing)程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。

当被监听的套接字准备好执行连接应答(accept)、读取(read)、写入(write)、关 闭 (close)等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套 接字之前关联好的事件处理器来处理这些事件。虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。

文件事件处理器主要是包含4个部分
```
多个socket(客户端连接)
IO多路复用程序(支持多个客户端连接的关键)
文件事件分派器(将socket关联到相应的事件处理器) 
事件处理器(连接应答处理器、命令请求处理器、命令回复处理器)
```

7.Redis为什么不用多线程

Redis 在 4.0 之后的版本中就已经加入了对多线程的支持，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会 使用主处理之外的其他线程来“异步处理”。

大体上来说，Redis 6.0之前主要还是单线程处理，主要原因有下面3个
```
单线程编程容易并且更容易维护;
Redis的性能瓶颈不在CPU，主要在内存和网络;
多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。
```

8.Redis6.0之后为何引入了多线程

Redis6.0 引入多线程主要是为了提高网络IO读写性能，因为这个算是Redis中的一个性能瓶颈(Redis的瓶颈主要受限于内存和网络)。

但是Redis的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。

Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改redis配置文件，同时要设置线程数
```
io-threads-do-reads yes
io-threads 4
```

9.Redis给缓存数据设置过期时间有啥用

因为内存是有限的，如果缓存中的所有数据都是一直保存的话，会造成OOM。

Redis自带了给缓存数据设置过期时间的功能
```
exp key 60 # 数据在 60s 后过期

setex key 60 value #set+exp Redis中除了字符串类型有自己独有设置过期时间的命令setex外，其他方法都需要依靠expire命令来设置过期时间 

ttl key # 查看数据还有多久过期

persist 命令可以移除一个键的过期时间
```

过期时间除了有助于缓解内存的消耗，还有什么其他用么?

很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在1分钟内有效，用户登录的token可能只在1天内有效。

如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。

10.Redis是如何判断数据是否过期的呢

Redis通过过期字典(可以看作是hash表)来保存数据过期的时间。过期字典的键指向 Redis数据库中的某个key(键)，过期字典的值是一个long long类型的整数，这个整数保存了key所 指向的数据库键的过期时间(毫秒精度的UNIX时间戳)。

11.过期的数据删除策略了解么

常用的过期数据的删除策略有惰性删除和定期删除。

惰性删除: 只会在取出key的时候才对数据进行过期检查。这样对CPU最友好，但是可能会造成太多过期key没有被删除（对内存不友好）。

定期删除 : 每隔一段时间抽取一批key执行删除过期key操作。并且，Redis底层会通过限制删除操作执行的时⻓和频率来减少删除操作对CPU时间的影响。

定期删除对内存更加友好，惰性删除对CPU更加友好。两者各有千秋，所以Redis采用的是定期删除+惰性/懒汉式删除。

但是，仅仅通过给key设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期key的情况。这样就导致大量过期key堆积在内存里，然后就Out of memory了。

怎么解决这个问题呢?答案就是: Redis内存淘汰机制。

12.Redis内存淘汰机制了解么

1. volatile-lru(least recently used):从已设置过期时间的数据集(server.db[i].expires) 中挑选最近最少使用的数据淘汰

2. volatile-ttl:从已设置过期时间的数据集(server.db[i].expires)中挑选剩余时间短的数据淘汰

3. volatile-random:从已设置过期时间的数据集(server.db[i].expires)中任意选择数据淘汰

4. allkeys-lru(least recently used):当内存不足以容纳新写入数据时，在键空间中，移除
最近最少使用的 key(这个是最常用的)

5. allkeys-random:从数据集(server.db[i].dict)中任意选择数据淘汰

6. no-eviction:禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报
错。

4.0 版本后增加以下两种:
7. volatile-lfu(least frequently used):从已设置过期时间的数据集(server.db[i].expires)中 挑选最不经常使用的数据淘汰

8. allkeys-lfu(least frequently used):当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key

13.Redis持久化机制

很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据，或者是为了防止系统故障而将数据备份到一个远程位置。

Redis的一种持久化方式叫快照(snapshotting，RDB)，另一种方式是只追加文件(append-only file, AOF)。

（1）

Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本 (Redis 主从结构，主要用来提高 Redis 性能)，还可以将快照留在原地以便重启服务器的时候使用。

快照持久化是Redis默认采用的持久化方式，在Redis.conf配置文件中默认有此下配置:
```
save 900 1 #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

save 300 10 #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

save 60 10000 #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
```

（2）

与快照持久化相比，AOF持久化的实时性更好，因此已成为主流的持久化方案。默认情况下Redis没有开启AOF(append only file)方式的持久化，可以通过appendonly参数开启:

```
appendonly yes
```

开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的 文件名是appendonly.aof。在Redis配置文件中存在三种不同的AOF持久化方式，它们分别是:
```
appendfsync always #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度 
appendfsync everysec #每秒钟同步一次，显示地将多个写命令同步到硬盘
appendfsync no #让操作系统决定何时进行同步
```
为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一 秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适 应硬盘的最大写入速度。

Redis 4.0 开始支持 RDB 和 AOF 的混合持久化(默认关闭，可以通过配置项 aof-use-rdb- preamble 开启)。如果把混合持久化打开，AOF重写的时候就直接把RDB的内容写到AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF里面的RDB部分的压缩格式不再是AOF格式，可读性􏰀差。

补充内容:AOF 重写

AOF 重写可以产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库
状态一样，但体积更小。

AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF 文件进行任何读入、分析或者写入操作。

在执行 BGREWRITEAOF 命令时，Redis服务器会维护一个AOF重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工 作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成 AOF文件重写操作。

14.redis事务

Redis可以通过 MULTI，EXEC，DISCARD 和 WATCH 等命令来实现事务(transaction)功能。

使用 MULTI命令后可以输入多个命令。Redis不会立即执行这些命令，而是将它们放到队列，当调用了EXEC命令将执行所有命令。

Redis的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性: 1. 原子性，2. 隔离性，3. 持久性，4. 一致性。Redis是不支持roll back 的，因而不满足原子性和持久性。

Redis开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。

可以将Redis中的事务就理解为:Redis事务提供了一种将多个命令请求打包的功能。然后， 再按顺序执行打包的所有命令，并且不会被中途打断。

15.缓存穿透

缓存穿透说简单点就是大量请求的key根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。

有哪些解决办法？

最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。

1)缓存无效key

如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如 下: SET key value EX 10086 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意 攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不 能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时 间设置短一点比如 1 分钟。

2)布隆过滤器

通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断key是否合法。

具体是这样做的:把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程：查看缓存中是否存在对应的数据，如果存在返回对应的数据；如果不存在看数据库中是否存在对应数据，若不存在返回空数据，若存在就更新缓存数据，然后返回对应的数据。

注意：布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。

为什么会出现误判的情况呢？我们先来看一下，当一个元素加入布隆过滤器中的时候，会进行哪些操作:
```
1. 使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值。(有几个哈希函数得到几个哈希值)。
2. 根据得到的哈希值，在位数组中把对应下标的值置为1。
```
我们再来看一下，当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作:
```
1. 对给定元素再次进行相同的哈希计算;
2. 得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过
滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。
```
然后，一定会出现这样一种情况:不同的字符串可能哈希出来的位置相同(可以适当增加位数组大小或者调整我们的哈希函数来降低概率).

16.缓存雪崩

缓存雪崩:缓存在同一时间大面积的失效，后面的请求 都直接落到了数据库上，造成数据库短时间内承受大量请求。数据库的压力可想而知，可能直接就被这么多请求弄宕机了。

举个例子:系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。还有一种缓存雪崩的场景是:有一些被大量访问数据(热点缓存)在某一时刻大面积失效，导致对应的请求直接落到了数据库上。

有哪些解决办法?

针对Redis服务不可用的情况: 1.采用Redis集群，避免单机出现问题整个缓存服务都没办法使用。2.限流，避免同时处理大量的请求。

针对热点缓存失效的情况:1.设置不同的失效时间比如随机设置缓存的失效时间。2.缓存永不失效。

17.如何保证缓存和数据库数据的一致性

下面单独对Cache Aside Pattern(旁路缓存模式)来聊聊

Cache Aside Pattern 中遇到写请求是这样的:更新DB，然后直接删除cache。

如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案:

```
1. 缓存失效时间变短(不推荐，治标不治本) :我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适 用。

2. 增加cache更新重试机制(常用): 如果cache服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以 把当前更新失败的key存入队列中，等缓存服务可用之后，再将缓存中对应的key删除即可。
```
18.跳表、数据和链表的区别

跳表在原有的有序链表上增加了多级索引，通过索引来实现快速查询。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。

每一层都是一个有序的链表，默认是升序 ；最底层(Level 1)的链表包含所有元素； 如果一个元素出现在Level i 的链表中，则它在Level i 之下的链表也都会出现；

每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。

单链表的查找时间复杂度为：O(n)，跳表查找时间复杂度为O(logn)。

比起单纯的单链表，跳表就需要额外的存储空间去存储多级索引，空间复杂度为O(n)。

跳表插入的时间复杂度为：O(logn)。在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的，就是O(1)。但是为了保证原始链表中数据的有序性，我们需要先找到要插入的位置，这个查找的操作就会比较耗时。对于跳表来说，查找的时间复杂度为O(logn)，所以这里查找某个数据应该插入的位置的时间复杂度也是O(logn)

跳表的删除操作时间复杂度为：O(logn)。在跳表中删除某个结点时，如果这个结点在索引中也出现了，我们除了要删除原始链表中的结点，还要删除索引中的。

当我们不断地往跳表中插入数据时，我们如果不更新索引，就有可能出现某2个索引节点之间的数据非常多的情况，在极端情况下，跳表还会退化成单链表。跳表是通过随机函数来维护“平衡性”。当我们往跳表中插入数据的时候，我们可以通过一个随机函数，来决定这个结点插入到哪几级索引层中。

19.redis持久化的方式

RDB：把某个时间点redis内存中的数据以二进制的形式存储的一个.rdb为后缀的文件当中,也就是周期性的备份redis中的整个数据,这是redis默认的持久化方式,也就是我们说的快照。

AOF：redis每次执行一个更改的数据的命令时,都会把这个命令原本的语句记录到一个.aof文件当中,然后通过fsync策略,将命令执行后的数据持久化到磁盘中。redis会自己对.aof文件进行优化,重建.aof文件，这个文件中包含了当前数据所需要的的最少的命令集。redis并不会让主进程进行这个操作,为了防止阻塞,在执行重写操作期间会设置一个aof重写缓冲区，仅仅用于在后台进程重写期间，将发生的数据库读写命令写入到重写缓冲区，之后当重写子进程完成重写后，向服务器主进程发送一个信号，此时服务器主进程将aof重写缓冲区中的命令追加到新的aof文件中去，用新的aof文件替换掉旧的aof文件。

RDB的两种工作方式：
（1）自动提交，这是redis中默认的配置。在900s内,有1个redis键有变化,就备份一次；在300s内,有10个redis键有变化,就备份一次；在60s内,有10000个redis键有变化,就备份一次。这个参数是我们可以修改的

（2）手动提交

save：该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。

bgsave：redis会自己fork出一条子进程,由这条子进程去执行,这样就不会影响到客户端对于redis 的正常操作。进程与进程之间的内存不是共享的,那么子进程是如何获取到主进程的内存数据呢?

在主进程fork子进程的同时,会把自己内存中的数据同时复制一份给子进程,这样就相当于子进程可以读取到主进程的数据了。那么就是说,会有双倍的内存占用.简单点来讲,假如你的redis在未fork子进程时就占用了5G内存,那么你的服务器剩余可用内存至少要达到5G才可正常的进行fork操作。

正常情况下redis的服务大部分都是读操作,在fork子进程的时候,子进程其实并没有直接复制一份主进程的数据,而是给他分配了一个虚拟的内存地址,指向了父进程的内存地址,知道父进程的内存数据发生改变的时候才会进行复制内存的操作。

如果在fork期间客户端又发起了新的操作,redis会等着。

fork这个过程结束后,redis的子进程就会进行持久化操作了,所以redis主进程理所应当的就创建了一份新的rdb文件,直到子进程完成持久化操作后,才会删除掉之前的rdb文件,以这份新的rdb文件代替。

fork的时间长短其实是跟当时redis中的数据量有很大关系的,在其他条件恒定的情况下,随着数据量的增大,redis 的fork操作时间也会变长。

为了性能,基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令。

RDB的优点： 1.它是将某一时间点redis内的所有数据保存下来,所以当我们做大型的数据恢复时,RDB的恢复速度会很快。2.由于RDB的FROK子进程这种机制,队友给客户端提供读写服务的影响会非常小

RDB的缺点: 1:假设我们定时5分钟备份一次,在10:00的时候redis备份了数据,但是如果在10:04的时候服务挂了,那么我们就会丢失在10:00到10:04的整个数据 2:,fork子进程这个过程是和redis的数据量有很大关系的,如果数据量很大,那么很有可能会使redis暂停几秒。

AOF命令同步到磁盘的三种方式：
```
appendfsync always #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度 
appendfsync everysec #每秒钟同步一次，显示地将多个写命令同步到硬盘
appendfsync no #让操作系统决定何时进行同步
```
AOF 的优点: 1.AOF可以更好的保护数据不丢失，一般AOF会以每隔1秒，通过后台的一个线程去执行一次fsync操作，如果redis进程挂掉，最多丢失1秒的数据。 2.AOF是将命令直接追加在文件末尾的,写入性能非常高。3.AOF日志文件的命令通过非常可读的方式进行记录，这个非常适合做灾难性的误删除紧急恢复，如果某人不小心用flushall命令清空了所有数据，只要这个时候还没有执行rewrite，那么就可以将日志文件中的flushall删除，进行恢复。

AOF 的缺点: 1.对于同一份数据源来说,一般情况下AOF文件比RDB数据快照要大。 2.由于.aof每次命令都会写入,那么相对于RDB来说需要消耗的性能也就更多。 3.数据恢复比较慢，不适合做冷备。

总结:

20.redis实现加锁的方式

（1）INCR

这种加锁的思路是， key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作进行加一。
然后其它用户在执行 INCR 操作进行加一时，如果返回的数大于 1 ，说明这个锁正在被使用当中。

  1、 客户端A请求服务器获取key的值为1表示获取了锁 

   2、 客户端B也去请求服务器获取key的值为2表示获取锁失败

  3、 客户端A执行代码完成，删除锁

  4、 客户端B在等待一段时间后在去请求的时候获取key的值为1表示获取锁成功

  5、 客户端B执行代码完成，删除锁

```
$redis->incr($key);
$redis->expire($key, $ttl); //设置生成时间为1秒
```

需要设置 key 过期时间，同时需要使用事务来确保请求的原子性。虽然只有一个请求的INCR可以成功获得锁，但是任何一个请求的 Expire 却都可以成功，这就意味着即便获取不到锁也可以刷新过期时间，导致锁一直有效。

（2）SETNX

setNX，是set if not exists 的缩写，也就是只有不存在的时候才设置, 设置成功时返回 1 ， 设置失败时返回 0 。可以利用它来实现锁的效果，但是很多人在使用的过程中都有一些问题没有考虑到。

例如某个查询数据库的接口因为请求量比较大所以加了缓存，并设定缓存过期后刷新。当并发量比较大并且缓存过期的瞬间，大量并发请求会直接查询数据库导致雪崩。如果使用锁机制来控制只有一个请求去更新缓存就能避免雪崩的问题。

这种加锁的思路是，如果 key 不存在，将 key 设置为 value；如果 key 已存在，则 SETNX 不做任何动作

  1、 客户端A请求服务器设置key的值，如果设置成功就表示加锁成功

  2、 客户端B也去请求服务器设置key的值，如果返回失败，那么就代表加锁失败

  3、 客户端A执行代码完成，删除锁

  4、 客户端B在等待一段时间后在去请求设置key的值，设置成功

  5、 客户端B执行代码完成，删除锁  

```
$redis->setNX($key, $value);
$redis->expire($key, $ttl);
```

通过 setNX 获取锁，如果成功了则更新缓存然后删除锁。有一个严重的问题：如果更新缓存的时候因为某些原因意外退出了，那么这个锁就不会被删除而一直存在，以至于缓存再也得不到更新。

所以要借助 Expire 来设置过期时间，同时需要使用事务来确保请求的原子性，以免setNX成功了Expire却失败了。虽然只有一个请求的 setNX 可以成功，但是任何一个请求的 Expire 却都可以成功，这就意味着即便获取不到锁也可以刷新过期时间，导致锁一直有效。

（3）SET

Redis从 2.6.12 起，SET 涵盖了 SETEX 的功能， SET 本身又包含了设置过期时间的功能，所以使用 SET 就可以解决上面遇到的问题。

  1、 客户端A请求服务器设置key的值，如果设置成功就表示加锁成功

  2、 客户端B也去请求服务器设置key的值，如果返回失败，那么就代表加锁失败

  3、 客户端A执行代码完成，删除锁

  4、 客户端B在等待一段时间后在去请求设置key的值，设置成功

  5、 客户端B执行代码完成，删除锁

```
$redis->set($key, $value, array('nx', 'ex' => $ttl)); //ex表示秒
```

到这一步其实还是有问题的，如果一个请求更新缓存的时间比锁的有效期还要长，导致在缓存更新过程中锁就失效了，此时另一个请求就会获取到锁，但前一个请求在缓存更新完毕的时候，直接删除锁的话就会出现误删其它请求创建的锁的情况。所以要避免这种问题，可以在创建锁的时候需要引入一个随机值并在删除锁的时候加以判断

```
$rs = $redis->set($key, $random, array('nx', 'ex' => $ttl));
if ($rs) {
     //处理更新缓存逻辑
    // ......
    //先判断随机数，是同一个则删除锁
    if ($redis->get($key) == $random) {
        $redis->del($key);
    }
}
```
（4） 其它问题

redis发现锁失败了要怎么办？中断请求还是循环请求？

答：使用循环请求，循环请求去获取锁

循环请求的话，如果有一个获取了锁，其它的再去获取锁的时候，是不是容易发生抢锁的可能？

答：在循环请求获取锁的时候，加入睡眠功能，等待几毫秒再执行循环。

21.本地缓存和redis的区别

本地缓存没有成熟的超时机制；本地缓存使用的是jvm的内存；各个进程间的缓存不可以共享；这种缓存没有持久化机制，随着服务的重启，缓存所占用的空间会释放掉；

集中式缓存（如redis），一般有成熟的expire超时机制；是和业务分离的独立的服务，使用的是redis本进程分配的缓存，不是jvm的缓存；这种缓存也叫分布式缓存，各个进程间可以共享，不需要在各个进程本地都缓存一份，可以保证各个进程间的缓存一致；支持持久化；

不考虑并发问题，本地缓存的读写速度是最快的。 Redis 这种还是需要网络开销，增加时耗。本地缓存是直接从本地内存中读取，没有网络开销，例如秒杀系统或者数据量小的缓存等，比远程缓存更合适。

redis缓存和本地缓存混用是一种非常实用的实践方式。

优点：极大地降低了redis的读写频率，特别是处理特别耗时的业务逻辑

缺点：会产生一定的延时，这个延时具体的影响将会根据业务的差别而定。一般来说，如果不涉及金钱交易，那可以防止99%以上的问题，就算是成功了。
