1.五层协议

2.TCP报文首部

3.三次握手

4.四次握手

5.如果已经建立了连接，但是客户端突然出现故障了怎么办

6.TCP,UDP协议的区别

7.TCP协议如何保证可靠传输

8.滑动窗口和流量控制

9.拥塞控制

10.流量控制和拥塞控制的区别

11.ARQ协议

12.在浏览器中输入url地址到显示主⻚的过程

13.DNS

14.HTTP请求

15.服务器处理请求并返回HTTP报文

16.get和post的区别

17.HTTP⻓连接,短连接

18.HTTP1.0和HTTP1.1的主要区别是什么

19.HTTP是不保存状态的协议,如何保存用户状态?

20.Cookie的作用是什么?和Session有什么区别?

21.HTTP和HTTPS的区别

22.httpheader头部信息

1.五层协议

OSI七层、TCP/IP四层、五层协议

五层协议

（1）应用层的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间的通信和交互的规则。

DNS：域名系统，可以将域名和IP地址相互映射的分布式数据库。

HTTP协议：从万维网服务器传输超文本到本地浏览器的传送协议。

（2）运输层的任务向两台主机进程之间的通信提供通用的数据传输服务。

“通用的”是指并不针对某一个特定的网络应用，多种应用可以使用同一个运输层服务。

由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。**复用**就是指多个应用层进程可同时使用下面运输层的服务，**分用**和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。

TCP：传输控制协议，提供面向连接的，可靠的数据传输服务。

UDP：用户传输协议，提供无连接的，尽最大努力的数据传输服务。

（3）网络层的任务是选择合适的网间路由和交换节点，确保数据及时传送。

（4）数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息。

数据链路层可以检测帧是否有差错，有差错可以简单的丢弃这个帧。如果要纠错，就要采用可靠性传输协议，这种方法会使链路层的协议复杂些。

（5）物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽具体物理介质和物理设备的差异。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不⻅的。

2.TCP报文首部

```
—————————————————————————————————————————————————————————————
16位源端口号                             16位目的端口号        |
—————————————————————————————————————————————————————————————
                           32位序号                          |
—————————————————————————————————————————————————————————————
                          32位确认序号                        |
—————————————————————————————————————————————————————————————
4位数据偏移|6位保留|U|A|P|R|S|F|             16位窗口          |
—————————————————————————————————————————————————————————————
           16位检验和         |          16位紧急指针          |
—————————————————————————————————————————————————————————————
                            选项                             |
—————————————————————————————————————————————————————————————
```
（1）TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。

（2）序号

TCP连接中传送的字节流中的每个字节都按顺序编号。用来标识TCP发送端向TCP接收端发送的数据字节流。

例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；

（3）确认号

期望收到对方下一个报文的第一个数据字节的序号。

例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；

（4）数据偏移

它指出TCP报文的数据距离TCP报文段的起始处有多远。

（5）保留，占6位，以后使用。目前每位都为0。

（6）标志字段

URG：当URG=1时，紧急指针字段有效，表示此报文段中有紧急数据，将紧急数据排在普通数据的前面。当接收端收到此报文后后必须先处理紧急数据，而后再处理普通数据。

ACK：仅当ACK=1时，确认号字段才有效。ACK用来表示确认发来的数据已经接收无误。TCP规定，在连接建立后所有报文的传输都必须把ACK置1。

PSH：PSH=1时，催促字段有效，接收端收到带有PSH标志的报文段，就尽快将数据提交给服务进程，而不是等到整个缓存都填满了再向上交付。

RST：当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接。

SYN：在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；

FIN：当FIN=1时，表明此报文的发送方的数据已经发送完毕，并且要求释放发送方到接收方的通道。

（7）窗口。

发送本报文段的一方的接受窗口。窗口值告诉对方：从本报文段首部中的确认号算起，目前允许对方发送的数据量。窗口值作为接收方让发送方设置其发送窗口的依据。

（8）检验和

校验首部和数据这两部分。

（9）紧急指针

指出本报文段中的紧急数据的字节数

（10）选项

长度可变，定义一些其他的可选的参数。

3.三次握手

三次握手的目的是建立可靠的通信信道，双方确认自己与对方的发送与接收都是正常的。

一次握手：客户端–发送带有SYN标志的数据包–服务端 

二次握手：服务端–发送带有SYN/ACK标志的数据包–客户端 

三次握手：客户端–发送带有带有ACK标志的数据包–服务端

详细过程：
```

1.TCP服务器进程创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；

2.TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，报文中SYN=1，ACK=0，同时选择一个初始序号seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。

3.TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中SYN=1，ACK=1，确认号是ack=x+1（因为接收到的报文数据长度为0），同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。

4.TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1（因为接收到的报文数据长度为0），自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。

5.当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。
```

（1）第一二三次握手时Client和Server分别确认了什么？

第一次握手:Client什么都不能确认;Server确认了对方发送正常，自己接收正常。

第二次握手:Client确认了自己发送、接收正常，对方发送、接收正常;Server确认了:对方发送正常，自己接收正常。

第三次握手:Client 确认了自己发送、接收正常，对方发送、接收正常;Server 确认了自己发送、接收正常，对方发送、接收正常。

所以三次握手就能确认双发收发功能都正常，缺一不可。

（2）接收端为什么要传回syn？

SYN是TCP/IP建立连接时使用的握手信号。

接收端传回发送端所发送的SYN是为了告诉发送端，我接收到的信息确实就是你所发送的信号。传了SYN，证明发送方到接收方的通道没有问题。

（3）传了SYN,为啥还要传ACK

ACK：在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。

双方通信无误必须是两者互相发送信息都无误。传了SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要ACK信号来进行验证。

（4）为什么TCP客户端最后还要发送一次确认呢？

防止已失效的连接请求报文传送到了服务端。

如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。

如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

4.四次挥手

断开一个TCP连接则需要四次挥手

客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送

服务器-收到这个 FIN，它发回一个ACK，确认序号为收到的序号加1 。和SYN一样，一个FIN 将占用一个序号

服务器-关闭与客户端的连接，发送一个FIN给客户端。

客户端-发回 ACK 报文确认，并将确认号设置为收到序号加1。

详细过程：
```
1.客户端进程发出连接释放报文，并且停止发送数据，报文FIN=1，序列号为seq=u（前面已经传送过来的数据的最后一个字节的序号加1）。客户端进入FIN-WAIT-1状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

2.服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v。服务端就进入CLOSE-WAIT状态。TCP服务器通知高层的应用进程，这时候进入半关闭状态。客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。服务端的CLOSE-WAIT状态还要持续一段时间。

3.客户端收到服务器的确认请求后，客户端就进入FIN-WAIT-2状态，等待服务器发送连接释放报文，在这之前还需要接受服务器发送的最后的数据。

4.服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w。此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

5.客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。

此时TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，客户端才进入CLOSED状态。

6.服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。
```
（1）为什么要四次挥手？

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，再发出连接释放通知，对方确认后就完全关闭了TCP连接。

（2）为什么客户端最后还要等待2MSL？

MSL:最长报文段寿命，TCP允许不同的实现可以设置不同的MSL值。

第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失。站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次。而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

第二，防止出现旧连接的请求报文。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。

（3）为什么建立连接是三次握手，关闭连接确是四次挥手呢？

建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。

而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

5.如果已经建立了连接，但是客户端突然出现故障了怎么办

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。

服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

6.TCP,UDP协议的区别

特点：TCP是面向连接的可靠传输，传输形式是字节流；UDP是无连接的不可靠传输，传输形式是数据报文段。

性能：TCP传输效率慢，所需资源多;UDP传输效率快，所需资源少。

应用场景：要求通信数据可靠的场景适合用TCP，如文件传输、邮件传输；要求通信速度高的场景适合用UDP，如域名转换。

首部字节：TCP20-60，UDP8个字节

UDP在传送数据之前不需要先建立连接，远地主机在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP确是一种最有效的工作方式(一般用于即时通信)，比如:QQ语音、QQ视频、直播等等。

TCP提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠的，面向连接的传输服务，难以避免地增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP一般用于文件传输、发送和接收邮件、远程登录等场景。

TCP的可靠体现在：TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。

7.TCP协议如何保证可靠传输

（1）TCP在传递数据之前，会有三次握手来建立连接；断开TCP连接需要四次挥手。

（2）应用数据被分割成TCP认为最适合发送的数据块。

（3）TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。

（4）校验和

TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和，不确认收到此报文段。

（5）TCP的接收端会丢弃重复的数据。

（6）流量控制

TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的 速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。(TCP利用滑动窗口实现流量控制)

（7）拥塞控制

当网络拥塞时，减少数据的发送。

（8）ARQ协议

也是为了实现可靠传输的。它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。

(9)超时重传

当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

8.滑动窗口和流量控制

TCP利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

9.拥塞控制

拥塞：在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。

拥塞控制的目的：为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。

拥塞控制的前提：网络能够承受现有的网络负荷。

为了进行拥塞控制，TCP发送方要维持一个拥塞窗口(cwnd) 的状态变量。

10.流量控制和拥塞控制的区别

拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。

相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制 所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取拥塞窗口和接收方的接受窗口中􏰀小的一个。

TCP的拥塞控制采用了四种算法。在网络层也可以使路由器采用适当的分组丢弃策略(如主动队列管理AQM)，以减少网络拥塞的发生。

（1）慢开始

算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为还不知道网络的情况。

先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。 cwnd初始值为1，每经过一个传播轮次，cwnd加倍。

（2）拥塞避免

拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1。

（3）快重传与快恢复

能快速恢复丢失的数据包。没有FRR，如果数据包丢失了，TCP将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了FRR，如果 接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认报文指出的数据段丢失了，并立即重传这些丢失的数据段。 有了FRR，就不会因为重传时要求的暂停被耽误。

当有单独的数据包丢失时，快速重传 和恢复(FRR)能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。

11.ARQ协议

自动重传请求是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。

（1）停止等待ARQ协议

停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认(回复ACK)。如果过了一段时间(超时时间后)，还是没有收到 ACK 确认，说 明没有发送成功，需要重新发送，直到收到确认后再发下一个分组;

在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认;

优点: 简单 

缺点: 信道利用率低，等待时间⻓

（2）连续ARQ协议

连续ARQ协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

优点: 信道利用率高，容易实现，即使确认丢失，也不必重传。

缺点: 不能向发送方反映出接收方已经正确收到的所有分组的信息。 Go-Back-N：需要退回来重传 已经发送过的 N 个消息。比如:发送方发送了 5条 消息，中间第三条丢失(3号)，这时接收方只能对前两个发送确认。发送方无法知道后三个分 组的下落，而只好把后三个全部重传一次。

1) 无差错情况: 发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。

2）超时重传

停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组 (认为刚才发送过的分组丢失了)。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据分组传输的平均往返时间更⻓一些。

12.在浏览器中输入url地址到显示主⻚的过程

打开一个网⻚，整个过程会使用哪些协议。

总体来说分为以下几个过程:
```
1. DNS解析(查找过程：浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、根域名服务器缓存、顶级域名服务器缓存、主域名服务器缓存)
2. TCP连接（TCP,IP,OPSF,ARP）
3. 发送HTTP请求（在TCP建立完成后，使用HTTP协议访问网页）
4. 服务器处理请求并返回HTTP报文 
5. 浏览器解析渲染⻚面
6. 连接结束
```
DNS：DNS解析的过程就是寻找哪台机器上有你需要资源的过程。互联网上每一台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，这个过程就是DNS解析。

HTTP协议：生成针对目标web服务器的HTTP请求报文。

TCP协议：将HTTP请求报文分割成报文段。

IP：建立TCP协议时，需要发送数据，发送数据在网络层使用IP协议。IP协议搜索对方的地址，一边中转一边传送。

OSPF：IP数据包在路由器之间，路由选择使用OPSF协议。

ARP：路由器与服务器通信时，使用ARP协议将ip地址转换为mac地址。

TCP协议：重组接收的报文段。

HTTP协议：对web服务器请求的内容进行处理。请求的结果也同样利用TCP/IP通信协议向用户进行回传。

13.DNS

DNS：DNS解析的过程就是寻找哪台机器上有你需要资源的过程。互联网上每一台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，这个过程就是DNS解析。

DNS解析是一个递归查询的过程。查找www.google.com的IP地址过程：
```
首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地(DNS高速缓存)，供下次查询使用。

网址的解析是一个从右向左的过程: com -> google.com -> www.google.com。但是真正的网址是www.google.com.，最右边这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，因此通常都会省略。浏览器在请求DNS的时候会自动加上，所以网址真正的解析过程为: . -> .com -> google.com. -> www.google.com.
```
DNS缓存：目的是对DNS优化。DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种:浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。

DNS负载均衡：DNS返回的IP地址是否每次都一样？如果每次都一样是否说明你请求的资源都位于同一台机器上面，那么这台机器需要多高的性能和储存才能满足亿万请求呢？

在用户的眼中，他需要的只是处理他的请求，哪台机器处理请求并不重要。DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。

CDN就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。

14.HTTP请求

它主要发生在客户端。发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议发送到服务器指定端口。

HTTP请求报文包括: 请求行，请求报头，空行和请求正文。

请求行：请求行由请求方法字段、URL字段和HTTP协议版本字段组成，用空格分隔。Method Request-URL HTTP-Version CRLF。例如GET index.html HTTP/1.1

常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD。

请求报头：允许客户端向服务器传递请求的附加信息和客户端自身的信息。由关键字/值对组成，每行一对，后面跟一个回车符和换行符。关键字和值用英文冒号“:”分隔。

常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent等。

Accept指定客户端用于接受哪些类型的信息，Accept-Encoding用于指定接受的编码方式。Content-Type定义返回内容的MIME类型。Authorization：HTTP授权的授权证书。

空行：最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。

请求正文：当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求报头中有一些与请求正文相关的信息。

15.服务器处理请求并返回HTTP报文

后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行，如Tomcat。

HTTP响应报文包括: 状态行，响应报头，空行和响应报文。

状态行：由HTTP协议的版本，状态码，状态代码的文本描述和CRLF组成。

状态码：由3位数组成，第一个数字定义了响应的类别，有五种可能取值。

1xx：指示信息–表示请求已接收，正在处理。

2xx：成功–表示请求已被成功接收、理解、接受。

3xx：重定向–要完成请求必须进行附加的操作。

4xx：客户端错误–请求有语法错误或无法处理。

5xx：服务器端错误–服务器未能实现合法的请求。

响应报头：用于描述数据和服务器的基本信息，可以通知客户端如何处理它返回的数据。

常见的响应报头字段有: Server, Connection...。

响应报文：服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分。

16.get和post的区别

Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。

（1）GET用于信息获取，而且是安全的和幂等的。安全的：该操作用于获取信息而非修改信息。幂等的：对同一URL的多个请求应该返回同样的结果。

POST是用于修改服务器上的资源的请求。

（2）GET传送的数据量较小，不能大于2KB。POST传送的数据量较大，一般默认为不受限制。 

（3）GET把参数包含在URL中，POST通过request body传递参数。GET请求在URL中传送的参数是有长度限制的，而POST没有。

（4）GET在浏览器回退时是无害的，而POST会再次提交请求。

（5）GET请求会被浏览器主动cache，而POST不会，除非手动设置。

（6）对参数的数据类型，GET只接受ASCII字符，而POST没有限制。

（7）GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。

（8）GET和POST的底层都是TCP/IP，如果给GET加上request body，给POST带上url参数，技术上是完全行的通的。 但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 虽然GET可以带request body，也不能保证一定能被接收到。

（9）GET产生一个TCP数据包；POST产生两个TCP数据包。

对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。

并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。

17.HTTP⻓连接,短连接

在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web⻚中包含有其他的Web资源(如JavaScript文件、图像文件、CSS文件等)，每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

从HTTP/1.1起，默认使用⻓连接，用以保持连接特性。使用⻓连接的HTTP协议，会在响应头 加入这行代码: Connection:keep-alive

在使用⻓连接的情况下，当一个网⻚打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep- Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件(如Apache)中设定这个时间。实现⻓连接需要客户端和服务端都支持⻓连接。

18.HTTP1.0和HTTP1.1的主要区别是什么

（1）在HTTP/1.0中，默认使用的是短连接；。HTTP1.1起，默认使用⻓连接 ,默认开启Connection: keep-alive。HTTP/1.1 的持续连接有非流水线方式和流水线方式 。流水线方式是客户在收到HTTP的响应报文之前 就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。

（2）错误状态响应码：在HTTP1.1中新增了24个错误状态响应码，如409(Conflict)表示请求的资源与资源的当前状态发生冲突;410(Gone)表示服务器上的某个资源被永久性的删除。

（3）缓存处理：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标 准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

（4）带宽优化及网络连接的使用：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要 某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206(Partial Content)。

19.HTTP是不保存状态的协议,如何保存用户状态?

HTTP是一种无状态协议，也就是说HTTP协议自身不对请求和响应之间的通信状态进行保存。

Session的主要作用就是通过服务端记录用户的状态。典型的场景是购物⻋，当你要添加商品到购物⻋的时候，系统不知道是哪个用户操作的，因为HTTP协议是无状态的。服务端给特 定的用户创建特定的Session之后就可以标识这个用户并且跟踪这个用户了。(一般情况下，服务 器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session)。

在服务端保存Session的方法很多，最常用的就是内存和数据库。

如何实现Session跟踪呢：

大部分情况下，我们都是通过在Cookie中附加一个Session ID来方式来跟踪。

Cookie 被禁用怎么办?

最常用的就是利用URL重写把Session ID直接附加在URL路径的后面。

20.Cookie的作用是什么?和Session有什么区别?

Cookie和Session都是用来跟踪浏览器用户身份的会话方式。

（1）Cookie一般用来保存用户信息，数据保存在客户端；Session的主要作用就是通过服务端记录用户的状态，数据保存在服务器端。

（2）相对来说Session安全性更高。如果要在Cookie中存储一些敏感信息，不要直接写入Cookie中，最好能将Cookie信息加密然后使用到的时候再去服务器端解密。

（3）应用场景

Cookie：比如1）在Cookie中保存已经登录过的用户信息，下次访问网站的时候⻚面可以自动帮你把登录的一些基本信息给填了。2）一般的网站都会有保持登录也就是 说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放一个Token在Cookie中，下次登录的时候只需要根据Token值来查找用户即可。为了安全考虑，重新 登录一般要将Token重写。3）登录一次网站后访问网站其他⻚面不需要重新登录。

Session典型的场景是购物⻋，当你要添加商品到购物⻋的时候，系统不知道是哪个用户操作的，因为HTTP协议是无状态的。服务端给特定的用户创建特定的Session之后就可以标识这个用户并且跟踪这个用户了。

21.HTTP和HTTPS的区别

默认端口: HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。

安全性和资源消耗：HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议。SSL/TLS运行在TCP之上，所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。HTTP安全性没有HTTPS高，但是HTTPS比HTTP耗 费更多服务器资源。

对称加密:密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等;

非对称加密:密钥成对出现(且根据公钥无法推知私钥，根据私钥也无法推知公钥)，加密解密使用不同密钥(公钥加密需要私钥解密，私钥加密需要公钥解密)，相对对称 加密速度􏰀慢，典型的非对称加密算法有RSA、DSA等。

22.httpheader头部信息

