1.面向对象和面向过程的区别。
2.Java语言有哪些特点
3.JVM 
4.JDK和JRE
5.Java和C++的区别
6.字符型常量和字符串常量的区别
7.构造器是否可被override
8.重载和重写的区别
9.封装继承多态
10.String、StringBuffer和StringBuilder的区别是什么?
11.自动装箱与拆箱
12.Java的布尔类型boolean在内存中占几个字节
13.在Java中定义一个不做事且没有参数的构造方法的作用
14.接口和抽象类的区别是什么
15.成员变量与局部变量的区别
16.创建一个对象用什么运算符?对象实体与对象引用有何不同?
17.构造方法有哪些特性？
18.静态方法和实例方法有何不同
19.对象的相等与指向他们的引用相等,两者有什么不同?
20.==与equals
21.hashCode与equals
22.为什么Java中只有值传递
23.简述线程、程序、进程的基本概念。以及他们之间关系是什么?
24.线程有哪些基本状态？
25.关于final关键字的一些总结
26.Java中的异常处理
27.Java序列化
28.为什么HashMap要自己实现writeObject和readObject方法？
29.获取用键盘输入常用的两种方法
30.Java中IO流
31.深拷⻉和浅拷⻉

1.面向对象和面向过程的区别。

面向过程：把解决问题的过程，拆成一个个方法，通过一个个方法的执行解决问题。

面向对象解决问题方式：先抽象出对象，然后用对象执行方法的方式解决问题。

面向对象有封装、继承、多态，可以设计出低耦合的系统，易维护、易复用、易扩展。

性能差异是来自于这个语言的执行机制，而不是这个语言采用的编程范式。类调用时需要实例化，开销比较大；而面向过程也需要分配内存，计算内存偏移量。

Java性能差的主要原因并不是因为它是面向对象语言，而是Java是半编译语言，最终的执行代码并不是可以直接被CPU执行的二进制机械码。c和c++就是很好的例子，两种语言执行效率差距其实并不大，但是两种语言的设计思想就不同。

2.Java语言有哪些特点

面向对象、平台无关性、支持多线程（C++11开始C++就引入了多线程库）、支持网络编程、编译与解释并存。

3.JVM 

JVM是运行Java字节码的虚拟机，JVM有针对不同系统的特定实现，目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的JVM实现是Java 语言“一次编译，随处可以运行”的关键所在。

Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点，所以Java程序运行时比较高效。

 .class->机器码：JVM类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比􏰀慢。后面引进了JIT编译器，而JIT属于运行时编译。当JIT编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。这也解释了我们为什么经常会说Java是编译与解释共存的语言。

HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的 只有那一小部分的代码(热点代码)，而这也就是JIT 所需要编译的部分。JVM会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK9引入了一种新的编译模式AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了JIT预热等各方面的开销。

JDK支持分层编译和AOT协作使用。但是，AOT编译器的编译质量是肯定比不上JIT编译器的。

分层编译：HotSpot内置两种JIT编译器，分别是client启动时的c1编译器和server启动时的c2编译器，c2在将代码编译成机器代码的时候需要搜集大量的统计信息以便在编译的时候进行优化，因此编译出来的代码执行效率比较高，代价是程序启动时间比较长，而且需要执行比较长的时间，才能达到最高性能；与之相反， c1的目标是使程序尽快进入编译执行的阶段，所以在编译前需要搜集的信息比c2要少，编译速度因此提高很多，但是付出的代价是编译之后的代码执行效率比较低。
分层编译，就是一种折中方式，在系统执行初期，执行频率比较高的代码先被c1编译器编译，以便尽快进入编译执行，然后随着时间的推移，执行频率较高的代码再被c2编译器编译，以达到最高的性能。

缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构（Xmixed）。

Xcomp: 完全采用即时编译器模式执行程序,如果即时编译出现问题,解释器会介入执行。

4.JDK和JRE

JRE是Java运行时环境。它是运行已编译Java程序所需的所有内容的集合，包括Java虚拟机(JVM)，Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。

JDK包括JRE，编译器(javac)和工具(如javadoc生成API文档和jdb调试器)。它能够创建和编译程序。

5.Java和C++的区别

都是面向对象的语言

Java不提供指针来直接访问内存，程序内存更加安全

Java的类是单继承的，C++支持多重继承;虽然Java的类不可以多继承，但是接口可以多继承。C++没有接口。

Java有自动内存管理机制，不需要程序员手动释放无用内存。

在C语言中，字符串或字符数组最后都会有一个额外的字符‘\0’来表示结束。但是，Java语言中没有结束符这一概念。

java中无需结束符的原因：Java里面一切都是对象，是对象的话，字符串肯定就有长度，即然有长度，编译器就可以确定要输出的字符个数，当然也就没有必要去浪费那1字节的空间用以标明字符串的结束了。比如，数组对象里有一个属性length,就是数组的长度，String类里面有方法length()可以确定字符串的长度，因此对于输出函数来说，有直接的大小可以判断字符串的边界，编译器就没必要再去浪费一个空间标识字符串的结束。

java和c通信的时候，由于c中的char中有结束符的，所以当java收到C发来的字符串时，后面往往会有若干空字符，如果不做处理的话，java会对其一并输出，为了将空字符处理掉不输出，可以调用java字符串的trim()方法。

6.字符型常量和字符串常量的区别

字符常量是单引号引起的一个字符，相当于一个整型值(ASCII值)，可以参加表达式运算。它可以是英文字母、数字、标点符号、以及由转义序列来表示的特殊字符。

字符串常量是双引号引起的若干个字符，代表一个地址值(该字符串在内存中存放位置)。

字符常量只占2个字节，字符串常量占若干个字节。

7.构造器是否可被override

不能被重写，但可以重载。

8.重载和重写的区别

重载：发生在编译期，在同一个类中方法名相同且参数列表不同。重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。

重载解析：编译器通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配，来挑选出相应的方法。如果编译器找不到匹配的参数，就会产生编译时错误。

重写：发生在运行期，是子类对父类的允许访问的方法进行重新编写。（两同两小一大）方法名和参数列表相同，返回值类型小于等于父类方法返回值类型，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。

如果父类方法访问修饰符为private/final/static则子类就不能重写该方法，但是被static修饰的方法能够被再次声明。

重写的返回值类型：如果方法的返回类型是void和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型， 重写时是可以返回该引用类型的子类的。

9.封装继承多态

封装：封装就是将一些细节信息隐藏起来，对于外界不可见。比如把一个对象的属性私有化，同时提供一些可以被外界访问的方法，如果属性不想被外界访问，不必提供方法给外界访问。方法就是一种封装，关键字private也是一种封装。

继承：使用已存在的类作为基础建立新类，新类可以定义新的属性和方法，也可以拥有父类的内容。通过继承能够复用以前的代码。继承主要解决的问题是共性抽取。

子类拥有父类对象所有的属性和方法(包括私有属性和私有方法)，但是父类中的私有属性和私有方法子类是无法直接访问的，只是拥有。

成员变量是从创建语句等号左边的类开始找，成员方法是从创建语句右边的类开始找。

多态：引用变量所指向的具体类型和通过该引用变量发出的方法调用到底是哪个类中实现的方法，在程序运行期间才能确定。父类引用指向子类对象，接口引用指向实现类对象。

多态的好处：代码统一。无论右边new的时候换成哪个子类的对象，等号左边调用方法都不会变化。

10.String、StringBuffer和StringBuilder的区别是什么?

String类中使用final关键字修饰字符数组来保存字符串，所以String对象是不可变的。在Java9之后，String类的实现改用byte数组存储字符串。

StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，但没有用 final关键字修饰，所以这两种对象都是可变的。

String中的对象是不可变的，也就可以理解为常量，线程安全。StringBuffer对方法加了同步锁或者对调用的方法加了同 步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。

每次对String类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String对象。StringBuffer每次都会对StringBuffer 对象本身进行操作，不生成新的对象。

操作少量的数据: 适用String

单线程字符串缓冲区下操作大量数据: 适用StringBuilder

多线程字符串缓冲区下操作大量数据: 适用StringBuffer

11.自动装箱与拆箱

装箱:将基本类型转换为对应的引用类型;

拆箱:将包装类型转换为基本数据类型;

在装箱的时候自动调用的是Integer的valueOf(int)方法。而在拆箱的时候自动调用的是Integer的intValue方法。

在通过valueOf方法创建Integer（Short,Long,Character也是）对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。

在通过valueOf方法创建Byte对象的时候，便返回指向ByteCache.cache中已经存在的对象的引用。

Double、Float的valueOf方法的实现是类似的，每次创建一个新的对象，因为在某个范围内的整型数值的个数是有限的，而浮点数却不是。

在Boolean中定义了2个静态成员属性TRUE和FALSE，TRUE = new Boolean(true)，FALSE = new Boolean(false)。所以Boolean类的引用只可能指向这两个对象中的一个。

Integer i = new Integer(xxx)和Integer i =xxx这两种方式的区别：第一种方式不会触发自动装箱的过程；而第二种方式会触发；第二种方式的执行效率和资源占用在一般性情况下要优于第一种情况。

```
public class Main {
    public static void main(String[] args) {
         
        Integer a = 1;
        Integer b = 2;
        Integer c = 3;
        Integer d = 3;
        Integer e = 321;
        Integer f = 321;
        Long g = 3L;
        Long h = 2L;
         
        System.out.println(c==d);
        System.out.println(e==f);
        System.out.println(c==(a+b));
        System.out.println(c.equals(a+b));
        System.out.println(g==(a+b));
        System.out.println(g.equals(a+b));
        System.out.println(g.equals(a+h));
    }
}

========

true
false
true
true
true
false
true
```

当 "=="运算符的两个操作数都是包装器类型的引用时，则比较指向的是否是同一个对象，如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。对于包装器类型，equals方法并不会进行类型转换。

c==(a+b)： a+b包含了算术运算，因此会触发自动拆箱过程（会调用intValue方法），因此它们比较的是数值是否相等。

c.equals(a+b)：先触发自动拆箱过程，再触发自动装箱过程，也就是说a+b，会先各自调用intValue方法，得到了加法运算后的数值之后，便调用Integer.valueOf方法，再进行equals比较。

g.equals(a+b)：先触发自动拆箱过程，再触发自动装箱过程，也就是说a+b，会先各自调用intValue方法，得到了加法运算后的数值之后，便调用Integer.valueOf方法，再进行equals比较。Integer和Long的数据类型不同，因此内容不相等。

12.Java的布尔类型boolean在内存中占几个字节

如果使用boolean声明一个基本类型的变量时，那么该变量占4个字节。单个boolean类型被编译成int类型来使用

如果使用boolean声明一个数组类型的时候，那么每个数组的元素占1个字节。对boolean array的操作使用byte array的opcode，每个单元一个字节。

13.在Java中定义一个不做事且没有参数的构造方法的作用

Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调 用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super() 来调用父类中特定的构造方法，则编译时将发生错误，因为Java 程 序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。

在调用子类构造方法之前会先调用父类没有参数的构造方法, 其目的是帮助子类做初始化工作。

14.接口和抽象类的区别是什么

（1）接口的方法默认是抽象方法，修饰符为public abstract。java8开始允许定义默认方法和静态方法，Java9允许定义私有方法。而抽象类可以有抽象方法和非抽象的方法。

（2）接口中定义成员变量只能用public static final修饰，而抽象类没有这种限制。

（3）一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。

（4）接口方法默认修饰符是public，java9的私有方法修饰符是private。抽象方法可以用public、protected和default这些修饰
符修饰。

（5）抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。

15.成员变量与局部变量的区别

如果成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。局部变量是在方法中定义的变量或是方法的参数。成员变量可以被各种修饰符修饰，而局部变量不能被访问控制修饰符及static修饰;但是，成员变量和局部变量都能被final所修饰。

成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。

对象存于堆内存。如果局部变量类型为基本数据类型，那么存储在栈内存。如果为引用数据类型，那存放的是指向堆内存对象的引用或者是指向常量池中的地址。

成员变量如果没有被赋初值，则会自动以类型的默认值而赋值。而局部变量不会自动赋值。

16.创建一个对象用什么运算符?对象实体与对象引用有何不同?

new创建对象实例(对象实例在堆内存中)，对象引用指向对象实例(对象引用存放在栈内存中)。一个对象引用可以指向0个或1个对象，一个对象可以有n 个引用指向它。

17.构造方法有哪些特性？

名字与类名相同，没有返回值。生成类的对象时自动执行，无需调用。

18.静态方法和实例方法有何不同

调用静态方法可以无需创建对象。在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。而实例方法只有对象名.方法名这种方式。

静态方法只能访问静态成员，不能访问实例成员变量和实例方法。实例方法则无此限制。

19.对象的相等与指向他们的引用相等,两者有什么不同?

对象的相等，比的是内存中存放的内容是否相等。而引用相等，比􏰀的是他们指向的内存地址是否相等。

20.==与equals

对于基本类型，==比较的是值。对于引用类型，==是判断两个对象的地址是不是相等。

equals():没有覆盖重写时，判断两个对象的地址是不是相等；覆盖重写后是比􏰀两个对象的内容是否相等。

当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相 同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。

21.hashCode与equals

hashCode()的作用是获取哈希码，也称为散列码。它实际上是返回一个int整数，这个哈希码的作用是确定该对象在哈希表中的索引位置。 

Object的hashcode方法是本地方法，也就是用c语言或c++实现的，该方法通常用来将对象的内存地址转换为整数之后返回。

以“HashSet如何检查重复”为例子来说明为什么要有hashCode：把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置。
如果发现有相同hashcode值的对象，这时会调用equals() 方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成 功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了equals的次数，相应就大大提高了执行速度。（hashcode 只是用来缩小查找成本。
）

为什么重写equals时必须重写hashCode方法：（1）为了保证同一个对象，在equals相同的情况下hashcode值必定相同。（2）提高效率，先进行hashcode比较，如果不同，那么就没必要再进行equals的比较了。

22.为什么Java中只有值传递

按值调用表示方法接收的是调用者提供的值，而按引用调用表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递 值调用所对应的变量值。

Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷⻉，不能修改传递给它的任何参数变量的内容。Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。

一个方法不能修改一个基本数据类型的参数，但可以改变对象的参数状态。外部对引用对象的改变会反映到所对应的对象上。

一个方法不能让对象参数引用一个新的对象。

23.简述线程、程序、进程的基本概念。以及他们之间关系是什么?

程序是含有指令和数据的文件，是静态的代码。

进程是程序的一次执行过程，是系统运行程序的基本单位。系统运行一个程序即是一个进程从创建，运行到消亡的过程。

一个进程就是一个执行中的程序，换句话说，当程序在执行时，将会被操作系统载入内存中。

线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。同一进程中多个线程共享同一块内存空间和一组系统资源。

24.线程有哪些基本状态？   

NEW：线程被创建，但还没有调用start()方法。

RUNNABLE：操作系统隐藏JVM中的READY和RUNNING状态，它只能看到RUNNABLE状态。所以Java系统一般将这两个状态统称为RUNNABLE(运行中)状态。线程创建之后它将处于 NEW(新建) 状态，调用 start() 方法后开始运行，线程这时候处于 READY(可运行) 状态。可运行状态的线程获得了cpu 时间片(timeslice)后就处于RUNNING(运行)状态。

BLOCKED：阻塞状态，表示线程阻塞于锁。

WAITING：表示当前线程需要等待其他线程做出一些特定动作。（通知或者中断）

TIME_WAITING：超时等待，不同于WAITING，可以在指定的时间自行返回。

TERMINATED：终止状态，表示当前线程已经执行完毕。

当线程执行 wait() 方法之后，线程进入 WAITING(等待)状态。进入等待状态的线程需要依靠 其他线程的通知才能够返回到运行状态，而 TIME_WAITING(超时等待) 状态相当于在等待状态 的基础上增加了超时限制，比如通过 sleep􏰁(long millis)􏰂方法或wait􏰁(long millis)􏰂方法可以将Java线程置于 TIMED WAITING状态。当超时时间到达后Java线程将会返回到RUNNABLE状态。

当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到BLOCKED(阻塞)状态。线程在执行Runnable的run()方法之后将会进入到TERMINATED(终止)状态。

25.关于final关键字的一些总结

final关键字主要用在三个地方:变量、方法、类。

对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改;如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。

修饰变量：表示变量一旦被赋值就不可以更改它的值。java中规定final修饰成员变量必须由程序员显式指定变量的值。

修饰类：表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。

修饰方法：表示方法不可被覆盖，但是可以重载。

使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义;第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升(现在的Java版本已经不需要使用final方法进行这些优化了)。类中所有的private 方法都隐式地指定为final。

要注意的是：父类中private的方法，在子类中不能访问该方法，但是子类与父类private方法相同的方法名、形参列表和返回值的方法，不属于方法重写，只是定义了一个新的方法。

26.Java中的异常处理

**Java异常类层次结构图**
```
                                            Object

                                            Throwable

                    Exception                                       Errors

Check Exceptions            Uncheck Exceptions

IOException                 RuntimeException及其子类
ClassNotFoundException 
SQLException 
或者一些自定义的异常
```

所有的异常都有一个共同的祖先java.lang包中的Throwable类。 Throwable类有两个重要的子类Exception(异常)和Error(错误)。Exception 能被程序本身处理(try-catch)，Error是无法处理的(只能尽量避免)。

Exception：程序本身可以处理的异常，可以通过try来进行捕获。Exception又可以分为受检查异常(必须处理)和不受检查异常(可以不处理)。

Error：属于程序无法处理的错误，我们没办法通过try来进行捕获。例如Virtual MachineError(JVM运行错误)、OutOfMemoryError(虚拟机内存不足)、NoClassDefFoundError(运行时JVM加载不到类)。这些异常发生时，JVM一般会选择线程终止。

受检异常：Java代码在编译过程中，如果受检查异常没有被catch/throw处理的话，就没办法通过编译。

不受检异常（运行时异常）：Java代码在编译过程中，即使不处理不受检查异常也可以正常通过编译。

Uncheck Exceptions： RuntimeException 及其子类都统称为非受检查异常。例如NullPointExecrption、NumberFormatException(字符串转换为数字)、ArrayIndexOutOfBoundsException(数组越界)、ClassCastException(类型转换错误)、ArithmeticException (算术错误)等。

Check Exceptions：IOException、ClassNotFoundException、SQLException或者一些自定义的异常。

**Throwable 类常用方法**

```
public string getMessage() :返回异常发生时的简要描述
public string toString() :返回异常发生时的详细信息
public string getLocalizedMessage() :返回异常对象的本地化信息。使用 Throwable 的子类覆
盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage􏰁􏰂 返回的结果相同
public void printStackTrace() :在控制台上打印 Throwable 对象封装的异常信息
```
**异常处理总结**

throws用于方法头,表示的只是异常的申明,而throw用于方法内部,抛出的是异常对象。throws可以一次性抛出多个异常，而throw只能一个。throws抛出异常时，它的上级（调用者）要申明抛出异常或者捕获，不然编译报错。而throw的话，可以不申明或不捕获（这是非常不负责任的方式）但编译器不会报错。

try块: 用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。

catch块: 用于处理try捕获到的异常。

finally块: 无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。

在以下3种特殊情况下，finally块不会被执行:

1.在try或finally块中用了System.exit(int)退出程序。但是，如果System.exit(int)在异常语句之后，finally还是会被执行。

2.程序所在的线程死亡。 

3.关闭CPU。

如果try语句里有return而finally里没有，那么代码的行为如下：
```
1.如果有返回值，就把返回值保存到局部变量中
2.执行jsr指令（Jump to Subroutine跳转到子程序）跳到finally语句里执行
3.执行完finally语句后，返回之前保存在局部变量表里的值
```
当try语句和finally语句中都有return语句时，在方法返回之前，finally语句的内容将被执行，并且finally语句的返回值将会覆盖原始的返回值。

**ClassNotfoundException和NoClassDefFoundError**

ClassNotfoundException异常一般是编译时找不到类，Console台就会输出异常信息。一般情况下，我们都会rebuild或者clean一下工程，让项目重新编译一遍。

ClassNotfoundException是在编译时JVM加载不到类或者找不到类导致的；而NoClassDefError是JVM在编译时能找到类，运行时JVM加载不到类。

NoClassDefFoundError发生在JVM在动态运行时，根据你提供的类名，在classpath中找到对应的类进行加载，但当它找不到这个类时，就发生了java.lang.NoClassDefFoundError的错误。如果这个类是确实存在的，说明这个类对于类加载器来说可能是不可见的。

NoClassDefFoundError错误发生原因：
```
类加载器三个机制：委托、单一性、可见性

委托：指加载一个类的请求交给父类加载器，若父类加载器不可以找到或者加载到，再加载这个类
单一性：指子类加载器不会再次加载父类加载器已经加载过的类
可见性：子类加载器可以看见父类加载器加载的所有类，而父类加载器不可以看到子类加载器加载的类

JVM的类加载机制的委托行机制，决定了类加载器只加载一次，子类加载器不会再加载父类加载器已经加载过的类。

所有在一些特定条件下就会出现编译时可以加载到类，运行时不可以加载到类，这时候就会出现java.lang.NoClassDefFoundError异常
```
（1）静态变量加载不到。检查日志文件中是否有java.lang.ExceptionInInitializerError这样的错误，NoClassDefFoundError有可能是由于静态初始化失败导致的。

（2）工程里没有将jar添加到classpath，maven项目中。

（3）在J2EE的环境，有多个不同的类加载器，也可能导致NoClassDefFoundError。

（4）程序的启动脚本覆盖了原来的classpath环境变量。

27.Java序列化

序列化：把Java对象转换为字节序列的过程。

反序列化：把字节序列恢复为Java对象的过程。

用途：（1）持久化对象。把对象的字节序列永久地保存到硬盘上，比如文件或者数据库。（2）网络传输对象。

一个对象要想实现序列化，必须要实现Serializable或者Externalizable（Serializable的子接口）。

（1）如果一个类中有引用类型的实例变量，这个引用类型也要实现Serializable接口。或者给该变量加transient关键字。当对象被反序列化时，被 transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。

（2）如果一个类实现了Serializable接口，那么它的所有子类都间接实现了此接口，所以它的子类可以被序列化。

（3）如果一个类实现了Serializable接口，而父类没有实现Serializable接口，这个子类是可以序列化的，但是在反序列化的过程中会调用父类 的无参构造函数。所以在其直接父类中必须有一个无参的构造函数。

（4）序列化保存对象的状态，而静态（static）变量不是对象的状态，所以它们不会被序列化。

**Serializable接口**

这个对象的所有属性（包括private属性、包括其引用的对象）都可以被序列化和反序列化来保存、传递。不想序列化的字段可以使用transient修饰。

由于Serializable对象完全以它存储的二进制位为基础来构造，因此并不会调用任何构造函数，因此Serializable类无需默认构造函数，但是当Serializable类的父类没有实现Serializable接口时，反序列化过程会调用父类的默认构造函数，因此该父类必需有默认构造函数，否则会抛异常。

使用transient关键字阻止序列化虽然简单方便，但被它修饰的属性被完全隔离在序列化机制之外，导致了在反序列化时无法获取该属性的值。

通过在需要序列化的对象的Java类里加入writeObject()方法与readObject()方法可以控制如何序列化各属性，甚至完全不序列化某些属性或者加密序列化某些属性。

在ObjectOutputStream中进行序列化操作的时候，会判断被序列化的对象是否自己重写了writeObject方法，如果重写了，就会调用被序列化对象自己的writeObject方法，如果没有重写，才会调用默认的序列化方法。

**Externalizable接口**

用户要实现的writeExternal()和readExternal()方法，用来决定如何序列化和反序列化。因为序列化和反序列化方法需要自己实现，因此可以指定序列化哪些属性，而transient在这里无效。

对Externalizable对象反序列化时，会先调用类的无参构造方法创建实例，然后才执行readExternal()方法进行反序列化。如果把类的不带参数的构造方法删除，或者把该构造方法的访问权限设置为private、默认或protected级别，会抛出java.io.InvalidException: no valid constructor异常，因此Externalizable对象必须有默认构造函数，而且必需是public的。

**使用**

若只想隐藏一个属性，比如用户对象user的密码pwd，如果使用Externalizable，并除了pwd之外的每个属性都写在writeExternal()方法里，这样显得麻烦，可以使用Serializable接口，并在要隐藏的属性pwd前面加上transient就可以实现了。如果要定义很多的特殊处理，就可以使用Externalizable。

虽然实现Externalizable接口能带来一定的性能提升，但由于实现ExternaLizable接口导致了编程复杂度的增加，所以大部分时候都是采用实现Serializable接口方式来实现序列化。

异同：

（1）Serializable序列化时不会调用默认的构造器，而Externalizable序列化时会调用默认构造器的。

（2）使用Externalizable时，必须按照写入时的确切顺序读取所有字段状态，否则会产生异常。而Serializable接口没有这个要求。

（3）Externalizable自定义序列化可以控制序列化的过程和决定哪些属性不被序列化。而Serializable可以在需要序列化的对象的Java类里加入writeObject()方法与readObject()方法可以控制如何序列化各属性。

**序列化版本**

序列化版本：该字段为被序列化对象中的serialVersionUID字段。

一个对象数据，在反序列化过程中，如果序列化串中的serialVersionUID与当前对象值不同，则反序列化失败，否则成功。

如果serialVersionUID没有显式生成，系统就会自动生成一个。生成的输入有：类名、类及其属性修饰符、接口及接口顺序、属性、静态初始化、构造器。任何一项的改变都会导致serialVersionUID变化。

例如，对于对象A，我们生成序列化的S(A)，然后修改A的属性，则此时A的serialVersionUID发生变化。反序列化时，S(A)与A的serialVersionUID不同，无法反序列化。会报序列号版本不一致的错误。

 一般系统都会要求实现serialiable接口的类显式的生明一个serialVersionUID，有两种用途：
 ```
 希望类的不同版本对序列化兼容时，需要确保类的不同版本具有相同的serialVersionUID。

 不希望类的不同版本对序列化兼容时，需要确保类的不同版本具有不同的serialVersionUID。
 ```
 如果我们保持了serialVersionUID的一致，则在反序列化时，对于新增的字段会填入默认值，对于减少的字段则直接忽略。

28.为什么HashMap要自己实现writeObject和readObject方法？

HashMap中有两个私有方法writeObject和readObject，但是在HashMap内部却找不到任何调用它们的地方。

readObject和writeObject方法都是为了HashMap的序列化而创建的。JDK提供的对于Java对象序列化操作的类是 ObjectOutputStream，反序列化的类是 ObjectInputStream。

ObjectOutputStream它提供了不同的方法用来序列化不同类型的对象，比如writeBoolean,wrietInt,writeLong等。对于自定义类型，提供了writeObject方法。ObjectOutputStream中进行序列化操作的时候，会判断被序列化的对象是否自己重写了writeObject方法，如果重写了，就会调用被序列化对象自己的writeObject方法，如果没有重写，才会调用默认的序列化方法。

**为什么HashMap中的readObject和writeObject都是私有的？**

如果我实现了一个继承HashMap的类，我也想有自己的序列化和反序列化方法，那我也可以实现私有的readObject和writeObject方法，而不用关心HashMap自己的那一部分。

**为什么HashMap要自己实现writeObject和readObject方法，而不是使用JDK统一的默认序列化和反序列化操作呢？**

一般来讲序列化和反序列化所在的机器是不同的，而序列化和反序列化的一个最基本的要求就是，反序列化之后的对象与序列化之前的对象是一致的。

HashMap中，由于Entry的存放位置是根据Key的Hash值来计算，然后存放到数组中的，对于同一个Key，在不同的JVM实现中计算得出的Hash值可能是不同的。有可能导致一个HashMap对象的反序列化结果与序列化之前的结果不一致，HashMap采用了下面的方式来解决：

（1）将可能会造成数据不一致的元素使用transient关键字修饰，从而避免JDK中默认序列化方法对该对象的序列化操作。不序列化的包括：Entry[ ] table,size,modCount。

（2）自己实现writeObject方法，从而保证序列化和反序列化结果的一致性。

**HashMap又是通过什么手段来保证序列化和反序列化数据的一致性的呢？**

HashMap序列化的时候不会将保存数据的数组序列化，而是将元素个数以及每个元素的Key和Value都进行序列化。在反序列化的时候，重新计算Key和Value的位置，重新填充一个数组。

29.获取用键盘输入常用的两种方法

（1）通过Scanner。（2）通过BufferedReader。

Scanner对象把回车,空格,tab键都看作输入结束，BufferedReader对象只将回车看作输入结束。BufferedReader是字符输入流中读取文本，缓冲各个字符，从而提供字符、数组和行的高效读取，速度要比Scanner快，而且也可以设置缓冲区的大小。

```
 
Scanner input = new Scanner(System.in);
String s = input.nextLine(); 
input.close();

 
BufferedReader input = new BufferedReader(new InputStreamReader(System.in)); 
String s = input.readLine();
```

30.Java中IO流

按照流的流向分，可以分为输入流和输出流。

按照操作单元划分，可以划分为字节流和字符流。

按照流的⻆色划分为节点流和处理流。

节点流：程序用于直接操作目标设备所对应的类。

处理流：程序通过一个间接流类去调用节点流类，以达到更加灵活方便地读写各种类型的数据。这个间接流类就是处理流。

Java I0流的40多个类都是从如下4个抽象类基类中派生出来的：InputStream，OutputStream，Reader，Writer。

既然有了字节流,为什么还要有字符流?
```
（1）如果音频文件、图片等媒体文件用字节流比􏰀好，如果涉及到字符的话使用字符流比􏰀好。

（2）字符流是由Java虚拟机将字节转换得到的，这个过程非常耗时，如果不知道编码类型就很容易出现乱码问题。所以，I/O 流就干脆提供了一个直接操作 字符的接口，方便我们平时对字符进行流操作。
```

BIO,NIO,AIO 有什么区别?

BIO (Blocking I/O): 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高(小于单机1000)的情况下，这种模型是比􏰀不错的，可以让每一个连接专注于自己的I/O并且编程模型简单，也不用过多考虑系统的过载、限流等问 题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。

NIO (Non-blocking/New I/O): NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以 理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。
NIO 提供了与传统 BIO 模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。 阻塞模式使用就像传统中的支持一样，比􏰀较简单，但是性能和可靠性都不好;非阻塞模式正 好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性;对于高负载、高并发的(网络)应用，应使用 NIO 的非阻塞模式来开发。

AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它 是异步非阻塞的IO模型。异步IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。 AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行 为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就 由这个线程自行进行 IO 操作，IO 操作本身是同步的。就目前来说AIO的应用还不是很广泛，Netty之前也尝试使用过 AIO，不过又放弃了。

31.深拷⻉和浅拷⻉

浅拷⻉:对基本数据类型进行值传递，对引用数据类型进行引用传递。

深拷⻉:对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容。
