1.什么是操作系统

2.系统调用

3.进程和线程

4.进程有哪几种状态

5.进程间的通信方式

6.线程间的同步方式

7.进程的调度算法

8.内存管理介绍

9.常⻅的几种内存管理机制

10.快表和多级⻚表

11.分⻚机制和分段机制的共同点和区别

12.逻辑地址和物理地址

13.CPU寻址了解吗?为什么需要虚拟地址空间?

14.什么是虚拟内存

15.局部性原理

16.虚拟内存的技术实现

17.⻚面置换算法

1.什么是操作系统

(1)操作系统本质上是一个运行在计算机上的软件程序，用于管理计算机硬件和软件资源。举例:运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。

(2)操作系统存在屏蔽了硬件层的复杂性。操作系统就像是硬件使用的负责人，统筹着各种相关事项。

(3)操作系统的内核(Kernel)是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。内核是连接应用程序和硬件的桥梁，决定着系统 的性能和稳定性。

2.系统调用

根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别:

1. 用户态(user mode): 用户态运行的进程可以直接读取用户程序的数据。

2. 系统态(kernel mode): 系统态运行的进程几乎可以访问计算机的任何资源，不受限制。

我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能，就需要系统调用了。

在我们运行的用户程序中，凡是与系统态级别的资源有关的操作(如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。

系统调用按功能分类：
```
设备管理。完成设备的请求或释放，以及设备启动等功能。 
文件管理。完成文件的读、写、创建及删除等功能。 
进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。 
进程通信。完成进程之间的消息传递或信号传递等功能。 
内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。
```

3.进程和线程的区别

进程是程序的一次执行过程，是系统运行程序的基本单位。线程比进程更小，是执行的基本单位。一个进程在其执行的过程中可以产生多个线程。

同一个进程里的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。所以系统在产生一个线程，或是在各个线程之间切换时，负担要比进程小得多。

线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护;而进程正相反。

4.进程有哪几种状态

创建状态(new) :进程正在被创建，尚未到就绪状态。

就绪状态(ready) :进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。

运行状态(running) :进程正在处理器上运行(单核CPU下任意时刻只有一个进程处于运行状态)。

阻塞状态(waiting) :进程正在等待某一事件而暂停运行如等待某资源为可用或等待IO操作完成。即使处理器空闲，该进程也不能运行。等待结束后并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态；

结束状态(terminated) :进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

5.进程间的通信方式

1.管道/匿名管道(Pipes):用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。

2.有名管道(Names Pipes): 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。

3.信号(Signal) :信号是一种比􏰀复杂的通信方式，用于通知接收进程某个事件已经发生;

4.消息队列(Message Queuing) :消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道(无名管 道:只存在于内存中的文件;命名管道:存在于实际的磁盘介质或者文件系统)不同的是消 息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列 时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进 先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。消息队列克服了信号承载信 息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。

5.信号量(Semaphores) :信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。

6.共享内存(Shared memory) :使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信 号量等。可以说这是最有用的进程间通信方式。

7.套接字(Sockets) : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端 点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

6.线程间的同步的方式

线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式:

（1）互斥量(Mutex): 采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如Java中的 synchronized关键词和各种Lock都是这种机制。

（2）信号量(Semphares): 它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。

（3）事件(Event): Wait/Notify:通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。

7.进程的调度算法

确定首先执行哪个进程以及最后执行哪个进程以实现最大CPU利用率。

先到先服务(FCFS)调度算法: 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用CPU时再重新调度。

短作业优先(SJF)的调度算法: 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用CPU时再重新调度。

时间片轮转调度算法： 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法， 又称RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许 运行的时间。

多级反馈队列调度算法：如果进程使用过多的CPU时间，那么它会被移到更低的优先级队列。较低优先级队列中等待过长的进程会被移到更高优先级队列。多级反馈队列调度算法既能使高优先级的作 业得到响应又能使短作业(进程)迅速完成，它是目前被公认的一种较好的进程调度算法。

优先级调度: 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有 相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来 确定优先级。

8.内存管理介绍

操作系统的内存管理主要负责内存的分配与回收(malloc 函数:申请内存，free 函数: 释放内存)，另外地址转换等功能也是操作系统内存管理做的事情。

9.常⻅的几种内存管理机制

简单分为连续分配管理方式和非连续分配管理方式这两种，连续分配管理方式是指为一个用户程序分配一个连续的内存空间（块式管理），非连续分配管理方式允许一个程序 使用的内存分布在离散或者说不相邻的内存中（⻚式管理，段式管理，段⻚式管理）。

（1）块式管理: 远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序 运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。

（2）⻚式管理: 把主存分为大小相等且固定的一⻚一⻚的形式，⻚􏰀小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。⻚式管理通过⻚表对应逻辑地址和物理地
址。

（3）段式管理: ⻚式管理虽然提高了内存利用率，但是⻚式管理其中的⻚实际并无任何实际意义。段式管理把主存分为一段段的，每一段的空间又要比一⻚的空间小很多 。但是，最重 要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段MAIN、子程序段X、数据段D及栈段S等。段式管理通过段表对应逻辑地址和物理地址。

（4）段⻚式管理

把主存先分成若干段，每个段又分 成若干⻚，也就是说 段⻚式管理机制 中段与段之间以及段的内部的都是离散的。

10.快表和多级⻚表

在分⻚内存管理中，很重要的两点是:

1.虚拟地址到物理地址的转换要快。

2.解决虚拟地址空间大，⻚表也会很大的问题。

（1）快表：引入了快表来加速虚拟地址到物理地址的转换。快表是一种特殊的高速缓冲存储器，其中的内容是⻚表的一部分或者全部内容，作用与⻚表相似。由于采用⻚表做地址转换，读写内存数据时CPU要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。

使用快表之后的地址转换流程是这样的:

1.根据虚拟地址中的⻚号查快表;

2.如果该⻚在快表中，直接从快表中读取相应的物理地址;

3.如果该⻚不在快表中，就访问内存中的⻚表，再从⻚表中得到物理地址，同时将⻚表中的该映射表项添加到快表中;

4.当快表填满后，又要登记新⻚时，就按照一定的淘汰策略淘汰掉快表中的一个⻚。

（2）多级⻚表

引入多级⻚表的主要目的是为了避免把全部⻚表一直放在内存中占用过多空间，特别是那些根本就不需要的⻚表就不需要保留在内存中。多级⻚表属于时间换空间的典型场景。

总结：为了提高内存的空间性能，提出了多级⻚表的概念；但是提升空间性能是以浪费时间性能为基础的，因此为了补充损失的时间性能，提出了快表(即 TLB)的概念。

不论是快表还是多级⻚表实际上都利用到了程序的局部性原理。

11.分⻚机制和分段机制的共同点和区别

共同点：分⻚机制和分段机制都是为了提高内存利用率，􏰀减少内存碎片。⻚和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个⻚和段中的内存是连续的。

区别：

（1）⻚的大小是固定的，由操作系统决定;而段的大小不固定，取决于我们当前运行的程序。

（2）分⻚仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。

12.逻辑地址和物理地址

我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存 储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操 作系统决定。物理地址指的是真实物理内存中地址，也就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。

13.CPU寻址了解吗?为什么需要虚拟地址空间?

现代处理器使用的是一种称为虚拟寻址的寻址方式，使用虚拟寻址，CPU需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。

实际上完成虚拟地址转换为物理地址的硬件是CPU中被称为内存管理单元（Memory Management Unit）的硬件。

没有虚拟地址空间的时候，程序直接访问和操作的都是物理内存。 这样带来的问题是：

（1）用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易(有意或者无意)破坏操作系统，造成操作系统崩溃。

（2）想要同时运行多个程序特别困难。举个简单的例子:微信在运行的时候给内存地址1xxx赋值后，QQ音乐也同样给内存地址1xxx赋值，那么QQ音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。

总结来说:如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。

通过虚拟地址访问内存有以下优势:

（1）程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。

（2）程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存⻚(通常大小为4KB)保存到磁盘文件。数据或代码⻚会根据需要在物理内存与磁盘之间移动。

（3）不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。

14.什么是虚拟内存

虚拟内存是计算机系统内存管理的一种技术，通过虚拟内存可以让程序拥有超过系统物理内存大小的可用内存空间。虚拟内存为每个进程提供了一个连续的、私有的地址空间，这样会更加有效地管理内存并减少出错。而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存(例如 RAM)的使用也更有效率。

虚虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且把内存扩展到硬盘空间。

虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。

15.局部性原理

局部性原理既适用于程序结构，也适用于数据结构。

局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。

程序在执行的时候往往呈现局部性规律，在某个􏰀短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。

时间局部性: 如果程序中的某条指令一旦执行，不久以后该指令可能再次执行;如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中 存在着大量的循环操作。

空间局部性: 一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序 存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。

时间局部性的实现：将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。

空间局部性的实现：使用􏰀较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。

16.虚拟内存的技术实现

虚拟内存的实现需要建立在离散分配的内存管理方式的基础上， 虚拟内存的实现有以下三种方式:

（1）请求分⻚存储管理：建立在分⻚管理之上，为了支持虚拟存储器功能而增加了请求调⻚功能和⻚面置换功能。请求分⻚是目前最常用的一种实现虚拟存储器的方法。请求分⻚存储管理 系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过 程中发现要访问的⻚面不在内存，则由处理器通知操作系统按照对应的⻚面置换算法将相应 的⻚面调入到主存，同时操作系统也可以将暂时不用的⻚面置换到外存中。

（2）请求分段存储管理：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分⻚储存管理方式一样，在作业开始运行之前，仅装入当前要 执行的部分段即可运行;在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段;当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便 腾出空间而装入新的段。

（3）请求段⻚式存储管理

不管是上面那种实现方式，我们一般都需要:
```
1.一定容量的内存和外存: 在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了;
2.缺⻚中断: 如果需执行的指令或访问的数据尚未在内存(称为缺⻚或缺段)，则由处理器通 知操作系统将相应的⻚面或段调入到内存，然后继续执行程序;
3.虚拟地址空间: 逻辑地址到物理地址的变换。
```
分⻚与分⻚存储管理的不同：它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分⻚存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分⻚存储管理可以提供虚存，而分⻚存储管理却不能提供虚存。

17.⻚面置换算法

地址映射过程中，若在⻚面中发现所要访问的⻚面不在内存中，则发生缺⻚中断。

缺⻚中断 就是要访问的⻚不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分⻚交换文件。

当发生缺⻚中断时，如果当前内存中并没有空闲的⻚面，操作系统就必须在内存选择一个⻚面将其移出内存，以便为即将调入的⻚面让出空间。用来选择淘汰哪一⻚的规则叫做⻚面置换算法，我们可以把⻚面置换算法看成是淘汰⻚面的规则。


OPT(最佳⻚面置换算法)：置换算法所选择的被淘汰⻚面将是以后永不使用的，或者是在最⻓时间内不再被访问的⻚面,这样可以保证获得最低的缺⻚率。但由于人们目前无法预知进程在内存下的若千⻚面中哪个是未来最⻓时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。

FIFO(先进先出⻚面置换算法)：总是淘汰最先进入内存的⻚面，即选择在内存中驻留时间最久的⻚面进行淘汰。

LRU(最少使用⻚面置换算法)：该置换算法选择在前段时期使用最少的⻚面作为淘汰⻚。
