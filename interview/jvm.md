1.Java内存区域(运行时数据区)

2.为什么要将永久代(PermGen)替换为元空间

3.直接内存

4.Java对象的创建过程

5.对象的访问定位有哪两种方式?

6.简单聊聊JVM内存分配与回收

7.堆内存中对象分配的基本策略

8.主要进行gc的区域

9.如何判断对象是否死亡

10.强引用,软引用,弱引用,虚引用

11.如何判断一个常量是废弃常量

12.如何判断一个类是无用的类

13.垃圾收集有哪些算法

14.HotSpot为什么要分为新生代和老年代

15.常⻅的垃圾回收器

16.JVM类加载机制

17.创建对象后在JVM中的生命周期

18.双亲委派模型

1.Java内存区域(运行时数据区)

Java虚拟机在执行Java程序的过程中会把它管理的内存划分成若干个不同的数据区域。

（1）程序计数器：可以看作是当前线程所执行的字节码的行号指示器，字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令。代码的流程控制需要通过程序计数器来完成。每条线程都有一个私有的程序计数器，用于记录当前线程执行的位置，当线程被切换回来的时候能够知道该线程上的执行状态。

程序计数器是一块􏰃小的内存空间。程序计数器是唯一一个不会出现OOM的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

（2）虚拟机栈

虚拟机栈是线程私有的，它的生命周期和线程相同。描述的是Java方法执行的内存模型，每次方法调用的数据都是通过栈传递的。

每个方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用、方法出口信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 JVM中入栈和出栈的过程。Java方法有两种返回方式，return和抛出异常，不管哪种返回方式都会导致栈帧被弹出。

局部变量表主要存放了编译期可知的各种数据类型，对象引用（可能是一个指向对象起始地址 的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）

Java虚拟机栈会出现两种错误
```
StackOverFlowError:若虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError错误。

OutOfMemoryError: 若虚拟机栈在扩展时无法申请到足够的内存空间，并且垃圾回收器也无法提供更多内存的话，就会抛出OutOfMemoryError错误。
```
（3）本地方法栈

虚拟机栈为虚拟机执行Java方法服务，本地方法栈为Native方法服务。在HotSpot虚拟机中和Java虚拟机栈合二为一。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、方法出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现StackOverFlowError和OutOfMemoryError 两种错误。

（4）堆

堆是Java虚拟机所管理的内存中最大的一块，被所有线程共享。堆在虚拟机启动时创建，用于存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。

从jdk1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用(也就是未逃逸出去)，那么对象可以直接在栈上分配内存。

Java堆是垃圾收集器管理的主要区域，因此也被称作GC堆。

现在收集器基本都采用分代垃圾收集算法，在jdk7中堆内存通常被分为新生代(Eden区，From Survivor，To Survivor)和老年代，JVM规范中把方法区描述为堆的一个逻辑部分，但方法区是非堆的。HotSpot中对方法区的实现方式为永久代。

jdk8之后HotSpot的永久代被移除了，用元空间代替，使用的是直接内存。

大部分情况，对象都会首先在Eden区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入survivor区，并且对象的年龄还会加1。当它的年龄增加到一定程度，就会被晋升到老年代中。对象晋升到老年代的年龄阈值是动态计算的。参数 -XX:MaxTenuringThreshold默认为15。Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和 MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值。

堆这里最容易出现的就是OOM错误，并且出现这种错误之后的表现形式还会有几种。
```
OutOfMemoryError: GC Overhead Limit Exceeded : 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
java.lang.OutOfMemoryError: Java heap space :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象,就会引发次错误。和本机物 理内存无关，和配置的内存大小有关。
```
（5）方法区

方法区是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

JVM规范中把方法区描述为堆的一个逻辑部分，但方法区是非堆的。

JVM规范只是规定了方法区的概念和作用，并没有规定如何去实现它。而永久代就是HotSpot对方法区的一种实现方式。

jdk1.7的永久代通过下面这些参数来调节方法区大小。垃圾收集行为在这个区域是比􏰃少出现的，但并非数据进入方法区后就“永久存在”
```
-XX:PermSize=N //方法区的初始大小
-XX:MaxPermSize=N //方法区的最大大小。超过这个值将会抛出OutOfMemoryError: PermGen
```
jdk1.7中方法区就被移除了，取代它的是元空间，使用的是直接内存。元空间溢出时会抛出OutOfMemoryError: MetaSpace
```
-XX:MetaspaceSize=N //设置 Metaspace 的初始(和最小大小) 
-XX:MaxMetaspaceSize=N //设置Metaspace的最大值。默认值为unlimited，它只受系统内存的限制。如果未指定此标志，则Metaspace 将根据运行时的应用程序需求动态地重新调整大小。
```
2.为什么要将永久代(PermGen)替换为元空间

（1）永久代大小受到jvm本身设置的上限的限制，无法进行调整，而元空间使用的是直接内存，受本机可用内存限制。虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。

MaxMetaspaceSize设置Metaspace的最大值。默认值为unlimited，它只受系统内存的限制。如果未指定此标志，则Metaspace 将根据运行时的应用程序需求动态地重新调整大小。

（2）运行时常量池

Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表(用于存放编译期生成的各种字面量和符号引用)。

JDK1.7之前运行时常量池逻辑包含字符串常量池，存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代。

JDK1.7中字符串常量池被单独拿到堆，运行时常量池剩下的东⻄还在方法区, 也就是hotspot中的永久代。

JDK1.8中字符串常量池在堆中，运行时常量池剩下的东⻄在元空间中。

3.直接内存

直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。

JDK1.4中加入的NIO(New Input/Output) 类，引入了一种基于通道(Channel) 与缓存区 (Buffer) 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样就能在一些场景中显 著提高性能，因为避免了在Java堆和Native堆之间来回复制数据。

本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

4.Java对象的创建过程

（1）类加载检查

虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

（2）分配内存

虚拟机为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定。为对象分配空间就是把一块确定大小的内存从Java堆中划分出来。

分配方式有“指针碰撞”和“空闲列表”两种，选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

指针碰撞：用过的内存全部整合到一边，没用过的内存放在另一边。中间有一个分界值指针，只需要向没用过的内存方向移动对象内存大小的位置即可。

适合堆内存规整的情况：Serial、ParNew。

空闲链表：虚拟机会维护一个列表，该列表中记录哪些内存快是可用的，在分配的时候找一块最够大的内存块来划分给对象实例，最后更新列表记录。

适合堆内存不规整的情况：CMS

创建对象必须要保证线程安全，虚拟机通常采用两种方式来保证线程安全:
```
CAS+失败重试:CAS是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作。如果因为冲突失败就重试，直到成功为止。虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。

TLAB:为每一个线程预先在Eden区分配一块儿内存，称为TLAB（线程本地分配缓存区）。JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配。
```

（3）初始化零值

虚拟机需要将分配到的内存空间都初始化为零值，不包括对象头，这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

（4）设置对象头

初始化零值完成之后，虚拟机要对对象进行必要的设置。例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象头中。

根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

（5）执行init方法

在上面工作都完成之后，从虚拟机的视⻆来看，一个新的对象已经产生了，但从Java程序的视⻆来看，对象创建才刚开始,\<init\> 方法还没有执行，所有的字段都还为零。

一般来说， 执行new指令之后会接着执行\<init\>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

5.对象的访问定位有哪两种方式?

Java程序通过栈上的reference数据来操作堆上的对象实例。对象的访问方式有虚拟机实现而定，目前主流的访问方式有使用句柄和直接指针两种。

（1）句柄

句柄中包含了对象实例数据与类型数据各自的具体地址信息。Java堆中划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址。

（2）直接指针

如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象的地址。

使用句柄来访问的最大好处是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。

6.简单聊聊JVM内存分配与回收

Java的自动内存管理主要是针对对象内存的分配和回收。同时，Java自动内存管理最核心的功能是堆内存中对象的分配与回收。

Java堆是垃圾收集器管理的主要区域，因此也被称作GC堆。现在收集器基本都采用分代垃圾收集算法。

新生代包括：Eden区、From Survivor区和To Survivor区。

大部分情况，对象都会首先在Eden区域分配，在一次新生代垃圾回收后，如果对象还存活则会进入Survivor区，并且对象的年龄还会加1。当它的年龄增加到一定程度，就会被晋升到老年代中。

对象晋升到老年代的年龄阈值是动态计算的。参数 -XX:MaxTenuringThreshold默认为15。Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和 MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值。

经过一次GC后，Eden区和"From"区已经被清空。这个时候，"From"和"To"会交换他们的⻆色，也就是新的"To"就是上次GC 前的“From”，新的"From"就是上次GC前的"To"。保证在下一次GC前，名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填 满，"To"区被填满之后，会将所有对象移动到老年代中。

7.堆内存中对象分配的基本策略

目前主流的垃圾收集器都会采用分代回收算法。

（1）大多数情况下，对象在新生代中eden区分配。当eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

（2）大对象直接进入老年代。大对象就是需要大量连续内存空间的对象，比如字符串、数组。为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。

分配担保机制：作用是避免FullGC过于频繁。在发生MinorGC之前，只要老年代最大可用的连续空间大于新生代所有对象的总空间，或者大于历次晋升到老年代对象的平均大小，就会进行Minor GC，否则将进行Full GC。

（3）⻓期存活的对象将进入老年代。

虚拟机给每个对象一个对象年龄(Age)计数器。

大部分情况，对象都会首先在Eden区域分配，在一次新生代垃圾回收后，如果对象还存活则会进入Survivor区，并且对象的年龄还会加1。当它的年龄增加到一定程度，就会被晋升到老年代中。

对象晋升到老年代的年龄阈值是动态计算的。参数 -XX:MaxTenuringThreshold默认为15。Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中的最小值，作为新的晋升年龄阈值。

8.主要进行gc的区域

部分收集 (Partial GC):

新生代收集(Minor GC / Young GC):只对新生代进行垃圾收集;

老年代收集(Major GC / Old GC):只对老年代进行垃圾收集。注意MajorGC在有的语境中也用于指代整堆收集;

整堆收集 (Full GC):收集整个Java堆和元空间。

分配担保机制：作用是避免FullGC过于频繁。在发生MinorGC之前，只要老年代最大可用的连续空间大于新生代所有对象的总空间，或者大于历次晋升到老年代对象的平均大小，就会进行Minor GC，否则将进行Full GC。

9.如何判断对象是否死亡

堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡。

（1）引用计数法

给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1;当引用失效，计数器就减1;任何时候计数器为0的对象就是不可能再被使用的。

这种方法无法解决循环引用问题。

（2）可达性分析算法

通过一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到GCRoots 没有任何引用链相连的话，则证明此对象是不可用的。

可达性分析就是标记可达对象，清除不可达对象。

虚拟机栈中引用的对象，本地方栈中引用的对象，方法区中静态属性引用的对象，方法区中常量池引用的对象。

10.强引用,软引用,弱引用,虚引用

无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。

Java根据生命周期的长短将引用类型分为强引用、软引用、弱引用、虚引用。

强引用：new一个对象就是强引用，这是使用最普遍的引用。当JVM的内存空间不足时，宁愿抛出OOM使程序异常终止，GC也不回收具有强引用的存活着的对象。

软引用：通过SoftReference类实现的，当JVM的内存空间不足时，就会去回收软引用指向的对象。软引用可用来实现内存敏感的高速缓存。

软引用可以与引用队列(ReferenceQueue)联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。

弱引用：通过WeakReference类实现的，在垃圾回收器线程扫描到具有弱引用的对象时，不管当前内存空间是否足够，都会回收它的内存。垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。

弱引用可以和一个引用队列(ReferenceQueue)联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。

虚引用：通过PhantomReference类实现的。任何时候可能被GC回收，就像没有引用一样。无法通过虚引用访问对象的任何属性或者函数，虚引用必须和引用队列(ReferenceQueue)联合使用。虚引用主要用来跟踪对象被垃圾回收的活动。

当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

一般很少使用弱引用与虚引用，使用软引用的情况􏰃多，这是因为软引 用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出。

11.如何判断一个常量是废弃常量

运行时常量池中主要回收的是废弃的常量。

假如在常量池中存在字符串 "abc"，如果当前没有任何String对象引用该字符串常量的话，就说明常量"abc"就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池。

12.如何判断一个类是无用的类

方法区/元空间主要回收的是无用的类。无用的类需要同时满足3个条件

(1)该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。

(2)加载该类的ClassLoader已经被回收。

(3)该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

虚拟机可以对满足上述3个条件的无用类进行回收，但不是必然被回收。

13.垃圾收集有哪些算法

（1）标记-清除算法

该算法分为“标记”和“清除”阶段，首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。

缺点：效率低，并且标记清除后会产生大量不连续的碎片。

（2）复制算法

将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。

（3）标记-整理算法

首先标记出所有不需要回收的对象，然后让所有存活的对象向一端移动，最后直接清理掉端边界以外的内存。

（4）分代收集算法

将java堆分为新生代和老年代，根据各个年代的特点选择合适的垃圾收集算法。

在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。

14.HotSpot为什么要分为新生代和老年代

主要是为了提升GC效率。将java堆分为新生代和老年代，根据各个年代的特点选择合适的垃圾收集算法。

在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。

15.常⻅的垃圾回收器

收集算法是内存回收的方法论，垃圾收集器是内存回收的具体实现。

根据具体应用场景选择适合自己的垃圾收集器。

JDK1.8默认使用的是Parallel Scavenge+Parallel Old。

（1）Serial收集器

这是一个单线程收集器，它只会使用一条垃圾收集线程去完成垃圾收集工作，在进行垃圾收集工作的时候必须暂停其他所有的工作线("Stop The World")，直到它收集结束。但优点是简单而高效，由于没有线程交互的开销，可以获得很高的单线程收集效率。Serial收集器对于运行在Client 模式下的虚拟机来说是个不错的选择。

新生代采用复制算法，老年代采用标记-整理算法。

（2）ParNew收集器

ParNew收集器是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为(控制参数、收集算法、回收策略等等)和Serial收集器一样。

新生代采用复制算法，老年代采用标记-整理算法。

它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器(真正意义上的并发收集器)配合工作。

并行(Parallel): 指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 

并发(Concurrent):指用户线程与垃圾收集线程同时执行(但不一定是并行，可能会交替执行)，用户程序在继续运行，而垃圾收集器运行在另一个CPU上。

（3）Parallel Scavenge

Parallel Scavenge收集器几乎和ParNew一样。但它的关注点是吞吐量(高效率的利用 CPU)，CMS等垃圾收集器的关注 点更多的是用户线程的停顿时间(提高用户体验)。

新生代采用复制算法，老年代采用标记-整理算法。

吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量。

如果对于收集器运作不太了解，手工优化存在困难的时候，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。

（4）Serial Old

Serial收集器的老年代版本，一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。

（5）Parallel Old

Parallel Scavenge 收集器的老年代版本。在注重吞吐量以及CPU资源的场合，都可以优先考虑Parallel Scavenge收集器和Parallel Old收集器。

（6）CMS收集器

CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。它适合在注重用户体验的应用上使用。

MS(Concurrent Mark Sweep)收集器是HotSpot虚拟机第一款真正意义上的并发收集器。它第一次实现了让垃圾收集线程与用户线程(基本上)同时工作。

CMS收集器是基于一种“标记-清除”算法实现的，分为四个步骤
```
初始标记: 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快;

并发标记: 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。

重新标记: 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍⻓，远远比并发标记阶段时间短。

并发清除: 开启用户线程，同时GC线程开始对未标记的区域做清扫。
```
主要优点：并发收集、低停顿

缺点：对CPU资源敏感、无法处理浮动垃圾、收集结束时会有大量空间碎片产生。

（7）G1收集器

面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征。

特点
```
并行与并发:G1 能充分利用CPU、多核环境下的硬件优势，使用多个CPU(CPU 或者 CPU 核心)来缩短Stop-The-World停顿时间。G1收集器可以通过并发的方式让java程序继续执行。

分代收集:虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了 分代的概念。

空间整合:与CMS的“标记--清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的 收集器;从局部上来看是基于“复制”算法实现的。

可预测的停顿:降低停顿时间是 G1 和 CMS 共同 的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个⻓度为 M 毫秒的时间片段内。
```
G1收集器的运作大致分为以下几个步骤:

初始标记,并发标记,最终标记,筛选回收。

G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限时间内可以尽可能高的收集效率。

16.JVM类加载机制

JVM把类加载到内存中，存在方法区中，并对数据进行验证，准备，解析和初始化，最终变成可以被虚拟机直接使用的class对象。

JVM类加载分为5个过程：加载，验证，准备，解析，初始化。而验证，准备，解析可以统称为连接。

（1）加载

通过类的全限定名称获取类的二进制流，将该二进制流的静态存储结构转换为方法区里运行时的数据结构，在堆中为该类生成一个class对象。

（2）验证

验证class文件中的字节流信息是否符合虚拟机的要求，不会威胁到jvm的安全。

（3）准备

为class对象的静态变量分配内存，初始化。

（4）解析

将符号引用转换成直接引用。

（5）初始化

开始执行类中定义的java代码。调用类的构造器等等。

**类加载器**

用来获取类的二进制字节流。

启动类加载器：加载java的核心类库，无法被java程序直接使用。

扩展类加载器：加载java的扩展库

系统类加载器：根据java类的路径来加载类，和我们的程序有关系

自定义类加载器：继承ClassLoader

17.创建对象后在JVM中的生命周期

在JVM运行空间中，对象的整个生命周期大致可以分为7个阶段：创建阶段（Creation）、应用阶段（Using）、不可视阶段（Invisible）、不可到达阶段（Unreachable）、可收集阶段（Collected）、终结阶段（Finalized）与释放阶段（Free）。

**创建阶段**

 为对象分配存储空间

开始构造对象

从超类到子类对static成员进行初始化

递归调用超类的构造方法,进行对象实例初始化与变量初始化。

**应用阶段**

对象至少被一个强引用持有

**不可见阶段**

程序的执行已经超出了该对象的作用域了,程序本身不再持有该对象的任何强引用。

**不可达阶段**

该对象不再被任何强引用所持有。

”GC root”中再也找不到任何直接的或者间接的弱引用。对象如果在之前的任何状态被JVM等系统下的某些已装载的静态变量或线程或JNI等强引用持有着，这些特殊的强引用被称为”GC root”。

**收集阶段**

垃圾回收器发现该对象已经处于“不可达阶段”，并且为该对象的内存空间重新分配做好了准备。如果没有重写finalize()方法，则标记为垃圾对象；如果该对象已经重写了finalize()方法，则会去执行该方法。
**终结阶段**

当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。

**释放阶段**

对象空间已被重用

18.双亲委派模型

当一个类加载器收到类加载的请求时，首先不会尝试自己去加载，而是将这个请求委派给父类的加载器去加载。只有父类加载器在搜索范围找不到当前类时，子类加载器才会自己去加载这个类。

双亲委派模型的目的：防止内存中出现多个相同的字节码。如果没有双亲委派机制，会产生多个String类，无法保证类的唯一性。String是不允许被继承的，他必须是唯一。

如何打破双亲委派模型：自定义类加载器，继承classloader，重写loaderclass和findclass方法。

