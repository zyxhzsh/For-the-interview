2020年11月19日

[力扣](https://leetcode-cn.com/problems/first-missing-positive/)

**描述**

给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。

你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。

- [思路一](#思路一)
- [思路二](#思路二)

#### 思路一

如果不限制空间复杂度为O(1)。可以用集合来做。

**如果知道最小正整数的取值范围[min,max]，用指针i从min遍历到max，每次查找数组中有没有i，数组中第一次没有出现过的i就是未出现的最小正整数。
而哈希集合的查找操作是o(1)时间复杂度的**。

注意数组的长度是有限的，所以此题不需要最大取值，只要从1开始遍历即可。从最小的整数1开始，看数组有没有这个整数。数组无序，但最小整数是有序的，从小到大开始找。1-m数组里都有，m+1没有，那m+1就是数组里没有的最小正整数。

1.先分析最小正整数的取值范围。

设数组长度是n，未出现的最小正整数记为x。

（1）数组没有1的时候，未出现的最小正整数就是1。而且不会有比1小的正整数。所以x最小为1。

（2）数组最多有n个正整数，数组中取最小的n个正整数时，即[1,2..n]，最小正整数x为n+1。数组不能再加元素了，所以x最大为n+1。

因此最小正整数的取值范围为[1,n+1]。

2.最小正整数的取值范围为[1,n+1]，所以只要在[1,n+1]里找哪个没出现就好了。

指针i从1遍历到n+1，第一个没出现的i就是最小正整数。遍历是O(n)，所以查找要为O(1)。而哈希集合查找是O(1)

（1）先遍历一遍把数组中的元素存到HashSet里。

（2）i从1遍历到n+1，集合中第一个没出现的i就是最小正整数。

时间复杂度O(n)，空间复杂度O(n)。

```java
import java.util.*;
public class Solution {
    public int minNumberdisappered (int[] arr) {
        int res=arr.length+1;
        Set<Integer> set = new HashSet<>();
        for(int i=0;i<arr.length;i++){
            set.add(arr[i]);
        }
        for(int i=1;i<=arr.length+1;i++){
            if(!set.contains(i)){
                res=i;
                break;
            }
        }
        return res;
    }
}
```

#### 思路二

如果本题没有额外的时空复杂度要求，那么就很容易实现：
```
我们可以将数组所有的数放入哈希表，随后从1开始依次枚举正整数，并判断其是否在哈希表中；
时间复杂度O(n)，空间复杂度O(n)。

我们可以从1开始依次枚举正整数，并遍历数组，判断其是否在数组中。
时间复杂度O(n^2)，空间复杂度O(1)。
```
只能利用给定数组中的空间来存储一些状态。如果题目给定的数组是不可修改的，那么就不存在满足时空复杂度要求的算法；但如果我们可以修改给定的数组，那么是存在满足要求的算法的。

没有出现的最小正整数只能在[1,N+1]中。将所有在[1,N] 范围内的数放入哈希表，也可以得到最终的答案。而给定的数组恰好长度为N，这让我们有了一种将数组设计成哈希表的思路：
```
对数组进行遍历，对于遍历到的数x，如果它在[1,N]的范围内，那么就将数组中的第x−1个位置（注意：数组下标从0开始）打上「标记」。
在遍历结束之后，如果所有的位置都被打上了标记，那么答案是N+1，否则答案是最小的没有打上标记的位置加1。
```
如何标记呢？

由于我们只在意[1,N]中的数，因此我们可以先对数组进行遍历，把不在[1,N] 范围内的数修改成任意一个大于N的数（例如N+1）。
这样一来，数组中的所有数就都是正数了，因此我们就可以将「标记」表示为「负号」。

遍历数组打标记时，由于一个数x可能已经被打了标记，因此这个数原本对应的数是其绝对值。如果这个数的绝对值小于等于n，就将数组中|x|-1位置的数变成负数。若已经为负数不需要再添加负号。

在遍历完成之后，如果数组中的每一个数都是负数，那么答案是N+1，否则答案是第一个正数的下标加1。

算法分为三步：

（1）第一次遍历将数组中所有小于等于0的数修改为N+1；

（2）第二次遍历，对于数组中的每一个数x，若绝对值小于等于N就将|x|-1位置的数变为负数。

（3）第三次遍历返回第一个正数的位置+1。若遍历结束没有没有返回，则说明1-N都存在，返回N+1。

时间复杂度应为O(n)。

空间复杂度为O(1)。

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        for(int i=0;i<n;i++){
            if(nums[i]<=0){
                nums[i]=n+1;
            }
        }

        for(int i=0;i<n;i++){
            int num=Math.abs(nums[i]);
            if(num<=n && nums[num-1]>0){
                nums[num-1]=-nums[num-1];                
            }
        }

        for(int i=0;i<n;i++){
            if(nums[i]>0)
                return i+1;
        }

        return n+1;
    }
}
```

