2020年11月19日

[力扣](https://leetcode-cn.com/problems/first-missing-positive/)

**描述**

给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。

你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。

#### 思路一

如果本题没有额外的时空复杂度要求，那么就很容易实现：
```
我们可以将数组所有的数放入哈希表，随后从1开始依次枚举正整数，并判断其是否在哈希表中；
时间复杂度O(n)，空间复杂度O(n)。

我们可以从1开始依次枚举正整数，并遍历数组，判断其是否在数组中。
时间复杂度O(n^2)，空间复杂度O(1)。
```
只能利用给定数组中的空间来存储一些状态。如果题目给定的数组是不可修改的，那么就不存在满足时空复杂度要求的算法；但如果我们可以修改给定的数组，那么是存在满足要求的算法的。

没有出现的最小正整数只能在[1,N+1]中。将所有在[1,N] 范围内的数放入哈希表，也可以得到最终的答案。而给定的数组恰好长度为N，这让我们有了一种将数组设计成哈希表的思路：
```
对数组进行遍历，对于遍历到的数x，如果它在[1,N]的范围内，那么就将数组中的第x−1个位置（注意：数组下标从0开始）打上「标记」。
在遍历结束之后，如果所有的位置都被打上了标记，那么答案是N+1，否则答案是最小的没有打上标记的位置加1。
```
如何标记呢？

由于我们只在意[1,N]中的数，因此我们可以先对数组进行遍历，把不在[1,N] 范围内的数修改成任意一个大于N的数（例如N+1）。
这样一来，数组中的所有数就都是正数了，因此我们就可以将「标记」表示为「负号」。

遍历数组打标记时，由于一个数x可能已经被打了标记，因此这个数原本对应的数是其绝对值。如果这个数的绝对值小于等于n，就将数组中|x|-1位置的数变成负数。若已经为负数不需要再添加负号。

在遍历完成之后，如果数组中的每一个数都是负数，那么答案是N+1，否则答案是第一个正数的下标加1。

算法分为三步：

（1）第一次遍历将数组中所有小于等于0的数修改为N+1；

（2）第二次遍历，对于数组中的每一个数x，若绝对值小于等于N就将|x|-1位置的数变为负数。

（3）第三次遍历返回第一个正数的位置+1。若遍历结束没有没有返回，则说明1-N都存在，返回N+1。

时间复杂度应为O(n)。

空间复杂度为O(1)。

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        for(int i=0;i<n;i++){
            if(nums[i]<=0){
                nums[i]=n+1;
            }
        }

        for(int i=0;i<n;i++){
            int num=Math.abs(nums[i]);
            if(num<=n && nums[num-1]>0){
                nums[num-1]=-nums[num-1];                
            }
        }

        for(int i=0;i<n;i++){
            if(nums[i]>0)
                return i+1;
        }

        return n+1;
    }
}
```
