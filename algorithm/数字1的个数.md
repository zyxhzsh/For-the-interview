2020年11月12日

[力扣](https://leetcode-cn.com/problems/number-of-digit-one/)

**描述**

给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。

示例:
```
输入: 13
输出: 6 
解释: 数字 1 出现在以下数字中: 1, 10, 11, 12, 13 。
```

#### 思路

如果使用暴力解法一般会超时，这里可以通过数学分析的方式解决问题。

只统计1在个位，十位，百位，... 出现的情况。

举个例子：1234

1.个位出现1的情况：

1，11，21，31，...，1231，...，1234

规律是每增加10个数，产生一个1，总数=n/10 + 1 + 修正值

2.十位出现1的情况：

10，11，...，19，20，...， 110，111，...，119，120，...，1210，1211，...，1219，...，1234

规律是每增加100个数，产生一个10个1，总数=n/100*10 + 10 + 修正值

同理：

百位出现1的情况：

规律是每增加1000个数，产生100个1，总数=n/100*100 + 100 + 修正值

上面的公式都有一个修正值，这个修正值的是用来处理一些细节问题的，

比如十位的情况：

如果100<=n<110，那么n/100*10 + 10 = 20，110，111，...，119也被计算进去了，这是不应该出现的，所以修正值是-10。

如果110<=n<119，那么n/100*10 + 10 = 20，那么n+1，...，119被计算进去了，修正值是- (119 - n)，比如n=118，只有119被多算了，需要修正，修正值是-1。

如果n>119，那么n/100*10 + 10 = 20，110，111，...，119被计算在内是合理的，此时修正值是0。

上面的过程我们可以使用循环来求，计算完个位上的情况，可以将n缩小10倍，包含1的个数扩大10倍。

时间复杂度：O(log_{10}(n))。

空间复杂度：O(1)。

```java
class Solution {
    public int countDigitOne(int n) {
        int num = n;
        long i = 1;
        int res = 0;

        while(num > 0)            
        { 
            if(num % 10 == 0) // 不包含1 -9 
                res += (num / 10) * i; // 修正值是 0
            
            if(num % 10 == 1) // 包含 1 - 9的一部分
                res += (num / 10) * i + (n % i) + 1; // 修正值是(n % i) + 1
            
            if(num % 10 > 1) // 包含1 - 9
                res += (num / 10) * i + i; // i   
        
            num = num / 10; // 比如109/10 = 10， 可以按10位的处理，因为i增量了10倍
            i = i * 10; // 每次1的个数是增加10倍
        }   
        return res;
    }
} 
```

