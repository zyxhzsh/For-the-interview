2020年9月15日

[力扣](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

[思路一](#思路一)

[思路二](#思路二)

**描述**

给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。

例如：
```
输入: 原始二叉搜索树:
              5
            /   \
           2     13

输出: 转换为累加树:
             18
            /   \
          20     13
```

#### 思路一

递归

反序中序遍历，首先我们判断当前访问的节点是否存在，如果存在就递归右子树，递归回来的时候更新总和和当前点的值，
然后递归左子树。如果我们分别正确地递归 root.right 和 root.left ，那么我们就能正确地用大于某个节点的值去更新此节点，然后才遍历比它小的值。

时间复杂度：O(n)

一个二叉树是没有环的，所以 convertBST 对于每个节点来说不会被调用超过 1 次。除去递归调用以外， convertBST 做的工作是常数时间的，所以线性次调用 convertBST 的运行时间是线性时间的。

空间复杂度：O(n)

使用之前的结论 convertBST 会被调用线性次，我们可以知道整个算法的空间复杂度也是线性的。考虑最坏情况，一棵树只有右子树（或者只有左子树），调用栈会一直增长直到到达叶子节点，也就是包含n个节点。

```java
class Solution {
    int sum=0;
    public TreeNode convertBST(TreeNode root) {
        if(root!=null){
            convertBST(root.right);
            sum+=root.val;
            root.val=sum;
            convertBST(root.left);
        }
        return root;
    }
}
```

#### 思路二

迭代

```java
```
