2020年9月18日

[力扣](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

**描述**

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:
```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```
示例 2:
```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```
示例 3:
```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
````

#### 思路

滑动窗口

如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的。这里的原因在于，假设我们选择字符串中的第k个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为rk，
那么当我们选择第k+1个字符作为起始位置时，首先从k+1到rk的字符显然是不重复的，并且由于少了原本的第k个字符，我们可以尝试继续增大rk。

这样我们就可以使用「滑动窗口」来解决这个问题了。在枚举结束后，我们找到的最长的子串的长度即为答案。

我们还需要使用一种数据结构来判断 是否有重复的字符，常用的数据结构为哈希集合。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符。

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();//哈希集合用来判断是否有重复的字符。
        int len = s.length();//字符串的长度
        int r=-1;//右指针，初始值为-1，相当于我们在字符串的左边界的左侧，还没有开始移动
        int ans=0;
        for(int i=0;i<len;i++){
            //不断地移动右指针,并将未出现的字符加入哈希表，直到出现了重复的字符。
            while(r<len-1 && !set.contains(s.charAt(r+1))){
                r++;
                set.add(s.charAt(r));
            }
            ans = Math.max(ans, r-i+1);//计算当前起始位置的无重复字符最长子串。
            set.remove(s.charAt(i)); //左指针向右移动一格，移除一个字符。
        }
        return ans;
    }
}
```

