### 二叉树

### 先序遍历

先序遍历递归实现
```java
  public void preorder(TreeNode root, List<Integer> list){
        if(root==null){
            return;
        }
        /*
        这里写访问当前节点的代码，以打印为例。
        */
        System.out.println(root.val);
        preorder(root.left,list);
        preorder(root.right,list);
  }
```

先序遍历迭代实现，需要借助栈。因为栈是先进后出，所以右子树先入栈，然后左子树再入栈。
```java
  public void preOrderIteration(TreeNode root){
        if(root==null)  return;
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while(!stack.isEmpty()){
            root=stack.pop();
            /*这里写访问当前节点的代码，以打印为例。
            */
            System.out.print(root.val+" ");
            
            if(root.right!=null){
                stack.push(root.right);
            }
            if(root.left!=null){
                stack.push(root.left);
            }
        }
  }
```
[力扣例题：](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)给定一个二叉树，返回它的前序遍历，方法返回值为List<Integer>。

递归实现
```
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        preOrderRecur(root, res);
        return res;
    }
    
    private void preOrderRecur(TreeNode root, List<Integer> res){
        if(root==null)  return;

        res.add(root.val);
        preOrderRecur(root.left, res);
        preOrderRecur(root.right, res);
    }
}
```
迭代实现
```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        preOrderIteration(root, res);
        return res;
    }
    
    private void preOrderIteration(TreeNode root, List<Integer> res){
        if(root==null)  return;
        Stack<TreeNode>  stack = new Stack<>();
        stack.push(root);
        while(!stack.isEmpty()){
            root=stack.pop();
            res.add(root.val);
            if(root.right!=null)    stack.push(root.right);
            if(root.left!=null)     stack.push(root.left);
        }
    }
}
```

### 中序遍历

中序遍历递归实现

```java
    public void inOrderRecur(TreeNode root){
        if(root==null)  return;
        inOrderRecur(root.left);
        /*这里写访问当前节点的代码，以打印为例。
         */
        System.out.println(root.val);
        inOrderRecur(root.right);
    }
```
中序遍历迭代实现
```java
    public void inOrderIteration(TreeNode root){
        if(root==null)  return;
        Stack<TreeNode> stack = new Stack<>();
        while(root!=null || !stack.isEmpty()){
            while(root!=null){
                stack.push(root);
                root=root.left;
            }
            root=stack.pop();
            System.out.print(root.val+" ");
            //不管root.right是不是null,root必须变成其右孩子，或者变成null。root若不变，就符合下一次while循环的循环条件，下次出栈的还是这个节点。会进入死循环
            root=root.right;//正确写法
            /*错误写法：
            if (node.right != null) {
                cur = node.right;
            }
            */
        }
    }
```
[力扣例题：](https://github.com/GrowTowardsSunlight/For-the-interview/blob/master/algorithm/二叉树的中序遍历.md)
