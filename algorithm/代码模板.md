### 二叉树

### 先序遍历

递归实现
```java
  public void preorder(TreeNode root, List<Integer> list){
        if(root==null){
            return;
        }
        /*
        这里写访问当前节点的代码，以打印为例。
        */
        System.out.println(root.val);
        preorder(root.left,list);
        preorder(root.right,list);
  }
```

迭代实现，需要借助栈。因为栈是先进后出，所以右子树先入栈，然后左子树再入栈。
```java
  public void preOrderIteration(TreeNode root){
        if(root==null)  return;
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while(!stack.isEmpty()){
            root=stack.pop();
            /*这里写访问当前节点的代码，以打印为例。
            */
            System.out.print(root.val+" ");
            
            if(root.right!=null){
                stack.push(root.right);
            }
            if(root.left!=null){
                stack.push(root.left);
            }
        }
  }
```
[力扣例题：](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)给定一个二叉树，返回它的前序遍历，方法返回值为List<Integer>。

递归实现
```
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        preOrderRecur(root, res);
        return res;
    }
    
    private void preOrderRecur(TreeNode root, List<Integer> res){
        if(root==null)  return;

        res.add(root.val);
        preOrderRecur(root.left, res);
        preOrderRecur(root.right, res);
    }
}
```
迭代实现
```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        preOrderIteration(root, res);
        return res;
    }
    
    private void preOrderIteration(TreeNode root, List<Integer> res){
        if(root==null)  return;
        Stack<TreeNode>  stack = new Stack<>();
        stack.push(root);
        while(!stack.isEmpty()){
            root=stack.pop();
            res.add(root.val);
            if(root.right!=null)    stack.push(root.right);
            if(root.left!=null)     stack.push(root.left);
        }
    }
}
```

### 中序遍历

迭代实现

