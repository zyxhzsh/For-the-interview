2020年9月7日

[力扣](https://leetcode-cn.com/problems/merge-two-sorted-lists)

* [思路一](#思路一)
* [思路二](#思路二)

**描述**

将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

示例：
```
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```
```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
```
#### 思路一

迭代

首先设定一个哑节点prehead，用于最后返回合并后的链表。我们维护一个prev指针，调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：
```
如果l1当前节点的值小于等于l2，就把l1当前的节点接在prev节点的后面,同时将l1和prev分别向前移动。
否则，就把l2当前的节点接在prev节点的后面,同时将l2和prev分别向前移动。
```
在循环终止的时候，l1和l2至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。

这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。

时间复杂度：O(n + m)。

空间复杂度：O(1)。
```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode head = new ListNode(0);
        ListNode cur = head;
        while(l1!=null && l2!=null){
            if(l1.val<=l2.val){
                cur.next=l1;
                cur=cur.next;
                l1=l1.next;
            }else{
                cur.next=l2;
                cur=cur.next;
                l2=l2.next;
            }
        }
        cur.next=l1!=null?l1:l2;
        return head.next;
    }
}
```
 #### 思路二
 
 递归
 
 当前l1节点的值小于等于当前l2节点的值时，合并l1和l2等价于
 ```
 l1.next=merge(l1.next, l2)
 ```
 当前l1节点的值大于l2节点的值时，合并l1和l2等价于
  ```
 l2.next=merge(l1, l2.next)
 ```
 
我们直接将以上递归过程建模，同时需要考虑边界情况。

如果l1或者l2一开始就是空链表，那么没有任何操作需要合并，只需要返回非空链表。

否则，我们要判断l1和l2哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。

时间复杂度：O(n+m)。

空间复杂度：O(n+m)。
```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1==null)
        {
            return l2;
        }
        else if(l2==null)
        {
            return l1;
        }
        else if(l1.val<=l2.val)
        {
            l1.next=mergeTwoLists(l1.next,l2);
            return l1;
        }
        else
        {
           l2.next=mergeTwoLists(l1,l2.next);
            return l2;
        }
    }
}
```
