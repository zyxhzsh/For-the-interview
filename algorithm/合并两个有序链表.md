2020年9月7日

[力扣](https://leetcode-cn.com/problems/merge-two-sorted-lists)

**描述**

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

示例：
```
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```
```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
```
#### 思路一

迭代

首先设定一个哨兵节点prehead，用于最后返回合并后的链表。我们维护一个prev指针，调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：
```
如果l1当前节点的值小于等于l2，就把l1当前的节点接在prev节点的后面,同时将l1指针往后移一位。否则，我们对l2做同样的操作。然后把prev向后移一位。
```
在循环终止的时候，l1和l2至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。

这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。
```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode prehead = new ListNode(-1);
        ListNode pre = prehead;

        if(l1==null)
        {
            return l2;
        }
        if(l2==null)
        {
            return l1;
        }

        while(l1!=null && l2!=null)
        {
            if(l1.val<=l2.val)
            {
                pre.next=l1;
                l1=l1.next;
            }
            else
            {
                pre.next=l2;
                l2=l2.next;
            }
            pre=pre.next;
        }

        pre.next=l1==null?l2:l1;

        return prehead.next;
    }    
}
```
