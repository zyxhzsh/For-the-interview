2020年11月20日

[力扣](https://leetcode-cn.com/problems/missing-number/)

- [思路一](#思路一)
- [思路二](#思路二)

**描述**

给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。

你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?

#### 思路一

原地哈希。若[0,n-1]都出现了，则没出现的是n。将所有在[0,n-1]范围内的数放入哈希表，就能得到最终的答案。而给定的数组恰好长度为N，这让我们有了一种将数组设计成哈希表的思路。

若元素x在[0,n-1]范围内，就将数组中的x位置打上「标记」。用负数作为标记，表示当前位置已被访问，而0的负数还是0，因此要先处理0。

（1）第一次遍历先处理0，若nums[i]=0，则将nums[i]设为大于等于n的数，比如设为n，然后将nums[0]变为负数。

一定要按照这个顺序，因为i可能为0，若i为0按此顺序：先设nums[0]=n，不会影响其他位置，然后令num[0]=-nums[0]=-n，标记了0位置，表示0已被访问。

（2）第二次遍历数组打标记，由于一个元素可能已经被打了标记，因此这个元素原本对应的数是其绝对值。如果元素x的绝对值小于n，就将数组中|x|位置的数变成负数。若该位置已经为负数可以不做任何操作。

（3）第三次遍历返回第一个正数的位置，注意这种方法先处理了0，所以元素不会出现0，别的处理方法如思路二就可能还有0。若遍历结束没有没有返回，则说明0-n-1都存在，返回n。


时间复杂度：O(n)。

空间复杂度：O(1)。

```java
class Solution {
    public int missingNumber(int[] nums) {

        int n = nums.length;
        
        for(int i=0;i<n;i++){
            if(nums[i] == 0)  {
                nums[i] = n;
                nums[0] = - nums[0];
            }
        }

        for(int i=0;i<n;i++){
            int a = Math.abs(nums[i]);
            if(0<a && a<=n-1){
                nums[a] = - Math.abs(nums[a]);
            }
        }

        for(int i=0;i<n;i++){
            if(nums[i]>0)   return i;
        }
        
        return n;
    }
}
```

#### 思路二

也可以只关注[1,n]范围内的数有没有出现，若x的绝对值在该范围内，则将数组中|x|-1位置的数变为负数。若[1,n]范围内的数都出现了，则0没有出现。

这样不用专门遍历一次找0，而是在做标记时处理0（因为0的负数还是0）：若|x|在[1,n]范围内，且|x|-1位置的数为0，则将该位置的数变为-(n+1)。这样既表示|x|出现了，也不会影响其他位置。

然后遍历数组，找出第一个大于等于0的数，返回其下标+1；注意这种方法，若0所在位置没有出现，0是不会被处理的。所以返回的是大于等于0的元素的下标+1。

时间复杂度：O(n)。

空间复杂度：O(1)。

```java
class Solution {
    public int missingNumber(int[] nums) {

        int n = nums.length;

        for(int i=0;i<n;i++){
            int a = Math.abs(nums[i]);
            if(0<a && a<=n){
                nums[a-1] = - Math.abs(nums[a-1]);
                if(nums[a-1]==0)    {
                    nums[a-1] = -(n+1);
                }
            }
        }

        for(int i=0;i<n;i++){
            if(nums[i]>=0)   return i+1;
        }
        
        return 0;
    }
}
```

### 思路三

位运算。

通过异或运算找到缺失的数字。对数组中所有元素进行异或，对[0,n]范围内所有数进行异或，然后将两个异或值进行异或，除了缺失的数字，其他数字都出现了两次，因此最后异或的结果就是缺失的数。
      
时间复杂度：O(n)。异或运算和二进制的位数有关，而位数是固定的，相对于数组的长度n来说，是O(1)的。

空间复杂度：O(1)。

```java
class Solution {
    public int missingNumber(int[] nums) {

        int n = nums.length;
        int res = 0;
        res = res ^ n;//数组的长度只有n，为了只用一个循环，还需要对n进行异或
        for(int i=0;i<n;i++){
            res = res ^ i ^ nums[i];
        }
        
        return res;
    }
}
```
