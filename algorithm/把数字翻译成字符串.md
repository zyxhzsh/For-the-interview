2020年11月12日

[力扣](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

**描述**

给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

示例 1:
```
输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"
```
提示：

0 <= num < 231

#### 思路

用f(i)表示以第i位结尾的前缀串翻译的方案数。

字符串的第i位置：

（1）可以单独作为一位来翻译

（2）如果第i−1位和第i位组成的数字在10到25之间，可以把这两位连起来翻译。

因此动态转移方程为：
```
记第i−1位和第i位形成的数字为x
如果10≤x≤25：f(i)=f(i-1)+f(i-2);
否则：f(i)=f(i-1)
```
f(i)只和它的前两项f(i−1) 和 f(i−2) 相关，我们可以运用「滚动数组」思想把f数组压缩成三个变量，这样空间复杂度就变成了O(1)。

时间复杂度：循环的次数是n的十进制位数，故时间复杂度为O(logn)。

空间复杂度：这里用了一个临时变量把数字转化成了字符串，而字符串的长度为n的十进制位数，故空间复杂度为O(logn)。

```java
class Solution {
    //用f(i)表示以第i位结尾的前缀串翻译的方案数
    public int translateNum(int num) {
        String src = String.valueOf(num);

        //p表示f(n-2)，初始化为f(0);q表示f(n-1)，初始化为f(1)。f(0)和f(1)均为1,所以r初始化为1
        int p = 1, q = 1, r=1;
        for (int i = 1; i <src.length(); ++i) {//i表示下标，求的r是f(i+1)。
            String pre = src.substring(i-1, i+1);
            if (pre.compareTo("25") <= 0 && pre.compareTo("10") >= 0) {
                //如果第i−1 位和第i位组成的数字在10到25之间，可以把这两位连起来翻译.
                r=p+q;
            }else{
                r=q;
            }
            p=q;//更新f(n-2)
            q=r;//更新f(n-1)
        }
        return r;
    }
}

```
