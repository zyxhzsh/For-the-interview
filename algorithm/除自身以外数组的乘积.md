2020年9月22日

[力扣](https://leetcode-cn.com/problems/product-of-array-except-self/)

[剑指](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/)

- [思路一](#思路一)

- [思路二](#思路二)

**描述**

#### 思路一

左右乘积列表

1.初始化两个空数组 L 和 R。对于给定索引 i，L[i] 代表的是 i 左侧所有数字的乘积，R[i] 代表的是 i 右侧所有数字的乘积。

2.两次遍历求出左右乘积列表。L[0] 应该是1，因为第一个元素的左边没有元素。R[len-1]应为1，因为最后一个元素的右边没有元素。

3.当R和L数组填充完成，我们只需要在输入数组上迭代，且索引 i 处的值为：L[i] * R[i]。

时间复杂度：O(n)。

空间复杂度：O(n)。

空间复杂度不符合要求，代码略。

#### 思路二

将L数组用输出数组来计算，然后用一个变量，动态构造R数组得到结果。

1.初始化answer数组，对于给定索引 i，answer[i] 代表的是 i 左侧所有数字的乘积。

2.用一个变量来r跟踪右边元素的乘积。并更新数组answer[i]==answer[i]∗r。然后r更新为r=r*nums[i]，其中变量r表示的就是索引右侧数字的乘积。

时间复杂度：O(N)，其中 NN 指的是数组 nums 的大小。分析与方法一相同。

空间复杂度：O(1)，输出数组不算进空间复杂度中，因此我们只需要常数的空间存放变量。

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
       int n=nums.length;
        if(n==0)    return nums;
        int[] answer = new int[n];
        
        //求出索引i左侧所有元素的乘积。最左边的元素左边没有元素，所以answer[0]=1
        int p1=1;
        for(int i=0;i<n;i++){//记录i左边元素的累乘
            answer[i]=p1;
            p1*=nums[i];
        }
        int p2=1;//记录j右边元素的累乘,最右边的元素右边没有元素，所以p2初始值为1。
        for(int j=n-1;j>=0;j--){
            answer[j]=answer[j]*p2;//对于索引 j，左边的乘积为 answer[j]，右边的乘积为p2,相乘就得到了结果。
            p2*=nums[j];//p2需要包含j右边所有的乘积，所以计算下一个结果时需要将当前值a[j]乘到r上。
        }
        return answer;
    }
}
```
