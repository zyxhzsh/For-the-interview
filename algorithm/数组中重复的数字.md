2020年10月23日

[力扣](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

**描述**

找出数组中重复的数字。

在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

示例 1：
```
输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 
```
限制：

2 <= n <= 100000

### 思路

最简单的方法是先把数组排序，然后从头到尾扫描排序后的数组即可。排序数组需要O(nlgn)的时间。

还可以用哈希集合，从头到尾扫描这个数组，每扫描到一个数字时，都可以用O(1)时间来判断哈希集合里是否已包含了该数字，如果没有就加入哈希集合，如果有就找到一个重复的数字。时间复杂度为O(n)，空间复杂度为O(n)。

数字在 0～n-1 的范围内，如果这个数组中没有重复的数字，数组排序后数字i将出现在下标为i的位置。由于数组中有重复的数字，有些位置可能存在多个数字，同时有些位置可能没有数字。

按照以下规则重排数组：从头到尾依次扫描这个数组中的每个数字，当扫描到下标为i的数字m时，首先比较这个数字是不是等于i。

如果是就接着扫描下一个数字；如果不是再拿m个第m个数字进行比较，如果相等就找到了一个重复的数；如果不等就把第i个数字和第m个数字交换，把m放到属于它的位置。

接下来再重复这个比较、交换的过程，直到我们发现一个重复的数。

时间复杂度时：O(n)。代码中有两层循环，但每个数字最多交换两次就能找到属于它自己的位置，因此总的时间复杂度时O(n)。

空间复杂度：O(1)。

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        int res=-1;
        for(int i=0;i<nums.length;i++){
            while(nums[i]!=i){
                if(nums[i]==nums[nums[i]]){
                    res=nums[i];
                    break;
                }
                int temp=nums[i];
                nums[i]=nums[nums[i]];
                nums[temp]=temp;
            }
        }
        return res;
    }
}
```


