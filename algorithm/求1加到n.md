2020年11月6日

[力扣](https://leetcode-cn.com/problems/qiu-12n-lcof/)

- [思路一](#思路一)
- [思路二](#思路二)

**描述**

求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

示例 1：
```
输入: n = 3
输出: 6
```
限制：

1 <= n <= 10000

#### 思路一

能用的只有加减法，赋值，位运算符以及逻辑运算符。

递归。不能使用条件判断语句，那么我们是否能使用别的办法来确定递归出口呢？答案就是逻辑运算符的短路性质。

时间复杂度：O(n)。递归函数递归n次，每次递归中计算时间复杂度为O(1)，因此总时间复杂度为O(n)。

空间复杂度：O(n)。递归函数的空间复杂度取决于递归调用栈的深度。

```java
class Solution {
    public int sumNums(int n) {
        boolean flag = n>0 && (n+=sumNums(n-1))>0;//第二个表达式，(n+=sumNums(n-1))后面随意填什么，只要结果是个boolean值即可。
        return n;
    }
}
```

#### 思路二

快速乘

考虑 A 和 B 两数相乘的时候我们如何利用加法和位运算来模拟，其实就是将 B 二进制展开，如果 B 的二进制表示下第 ii 位为 1，那么这一位对最后结果的贡献就是 A*(1<<i)A∗(1<<i) ，即 A<<iA<<i。
我们遍历 B 二进制展开下的每一位，将所有贡献累加起来就是最后的答案，这个方法也被称作「俄罗斯农民乘法」

这个方法经常被用于两数相乘取模的场景，如果两数相乘已经超过数据范围，但取模后不会超过，我们就可以利用这个方法，保证每次运算都在数据范围内：
```
(a * b) mod n = [ (a mod n) * (b mod n) ] mod n
```
如果题目没有限制，代码如下
```java
class Solution {
    public int sumNums(int n) {
        int ans = 0;
        int A=n;
        for (int B=n+1; B>0; B >>= 1) {
            if ((B&1)==1) {
                ans += A;
            }
            A <<= 1;
        }
        return ans>>1;
    }
}
```
但不能用for和if，可以自己手动展开，因为题目数据范围n为[1,10000]，所以n二进制展开最多不会超过14位，手动展开14层代替循环即可。

时间复杂度：O(logn)。快速乘需要的时间复杂度为O(logn)。

空间复杂度：O(1)。只需要常数空间存放若干变量。

```java
class Solution {
    public int sumNums(int n) {
        int A=n;
        int B=n+1;
        int res=0;
        boolean flag;
        //1
        flag = (B&1)>0 && (res+=A)>0;
        A<<=1;
        B>>=1;
        //2
        flag = (B&1)>0 && (res+=A)>0;
        A<<=1;
        B>>=1;
        //3
        flag = (B&1)>0 && (res+=A)>0;
        A<<=1;
        B>>=1;
        //4
        flag = (B&1)>0 && (res+=A)>0;
        A<<=1;
        B>>=1;
        //5
        flag = (B&1)>0 && (res+=A)>0;
        A<<=1;
        B>>=1;
        //6
        flag = (B&1)>0 && (res+=A)>0;
        A<<=1;
        B>>=1;
        //7
        flag = (B&1)>0 && (res+=A)>0;
        A<<=1;
        B>>=1;
        //8
        flag = (B&1)>0 && (res+=A)>0;
        A<<=1;
        B>>=1;
        //9
        flag = (B&1)>0 && (res+=A)>0;
        A<<=1;
        B>>=1;
        //10
        flag = (B&1)>0 && (res+=A)>0;
        A<<=1;
        B>>=1;
        //11
        flag = (B&1)>0 && (res+=A)>0;
        A<<=1;
        B>>=1;
        //12
        flag = (B&1)>0 && (res+=A)>0;
        A<<=1;
        B>>=1;
        //13
        flag = (B&1)>0 && (res+=A)>0;
        A<<=1;
        B>>=1;
        //14
        flag = (B&1)>0 && (res+=A)>0;
        A<<=1;
        B>>=1;
        return res>>1;
    }
}
```
