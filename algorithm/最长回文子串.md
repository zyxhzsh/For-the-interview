2020年9月5日

[力扣](https://leetcode-cn.com/problems/longest-palindromic-substring/)

**描述**

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
示例 2：

输入: "cbbd"
输出: "bb"


### 思路三

见[manacher算法](https://github.com/GrowTowardsSunlight/For-the-interview/blob/master/algorithm/%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.md#%E6%80%9D%E8%B7%AF%E4%B8%89)
```
p[i]=预处理字符串拓展的步数=预处理字符串半径-1=(预处理字符的回文子串长度-1)/2=原始字符串的回文子串长度。
       
预处理字符串的回文子串左边为i-p[i],最左边一定为#，而预处理字符串最左边为$,故i-p[i]为偶数。
而原始回文子串最左边的字符在预处理字符串中的索引为i-p[i]+1,且(i-p[i]+1)为奇数。
因为预处理字符串最左边为$，故begin=(i-p[i]+1-1)/2=(i-p[i])/2。
        
由于p[i]为原始字符串的回文长度，故end=begin+p[i]-1。
而substring不包括结束索引，故结束索引=end+1=begin+p[i];
```
```java
class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        StringBuffer t = new StringBuffer("$#");
        for (int i = 0; i < n; ++i) {
            t.append(s.charAt(i));
            t.append('#');
        }
        t.append("!");
        n=t.length();

        int[] p = new int[n];
        int maxright=0,center=0,mirror=0,ans=0;
        int maxi=0,maxpi=0;

        for(int i=1;i<n-2;i++)
        {
            mirror=2*center-maxright;

            if(i<maxright)
            {
                p[i]=Math.min(maxright-i,p[mirror]);
            }
            else
            {
                p[i]=0;
            }

            while(t.charAt(i-p[i]-1)==t.charAt(i+p[i]+1))
            {
                p[i]++;
            }

            if(i+p[i]>maxright)
            {
                maxright=i+p[i];
                center=i;
            }

            if(p[i]>maxpi)
            {
                maxi=i;
                maxpi=p[i];
            }
        }
        /*
        p[i]=预处理字符串拓展的步数=预处理字符串半径-1=(预处理字符的回文子串长度-1)/2=原始字符串的回文子串长度。
       
        预处理字符串的回文子串左边为i-p[i],最左边一定为#，而预处理字符串最左边为$,故i-p[i]为偶数。
        而原始回文子串最左边的字符在预处理字符串中的索引为i-p[i]+1,且(i-p[i]+1)为奇数。
        因为预处理字符串最左边为$，故begin=(i-p[i]+1-1)/2=(i-p[i])/2。
        
        由于p[i]为原始字符串的回文长度，故end=begin+p[i]-1。
        而substring不包括结束索引，故结束索引=end+1=begin+p[i];
        */
        return s.substring((maxi-maxpi)/2,(maxi+maxpi)/2);
    }
}
```
