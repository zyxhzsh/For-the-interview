### 排序

[直接插入排序](#直接插入排序)
    
[冒泡排序](#冒泡排序)
    
[快速排序](#快速排序)
    
[归并排序](#归并排序)
    
[堆排序](#堆排序)
    
[](#)
    
### 直接插入排序

```java
public void InsertSort(int[] arr){

    int n = arr.length;
    int temp;
    for(int i=1;i<n;i++){
        temp = arr[i];
        int j;
        for(j=i-1;j>=0;j--){
            if(arr[j]>temp){
                arr[j+1]=arr[j];
            }else{
                break;
            }
        }
        arr[j+1] = temp;
    }
}

```

### 冒泡排序

```java
    private void bubbleSort(int[] nums){
        //正序
            int n = nums.length;
            for(int i=0;i<n-1;i++){
                for(int j=0;j<n-1-i;j++){
                    if(nums[j]<=nums[j+1])  continue;
                    int temp = nums[j];
                    nums[j] = nums[j+1];
                    nums[j+1] = temp;
                }
            }
    }
```

### 快速排序

首先要找到一个中枢，把小于中枢的值放到他前面，大于中枢的值放到他的右边，然后再以此方法对这两部分数据分别进行快速排序。

```java
    private void quickSort(int[] arr, int low, int high){
        if(low>=high)    return;
        int cur = partition(arr, low, high);
        quickSort(arr,low,cur-1);
        quickSort(arr,cur+1,high);
    }
    
    private int partition(int[] nums, int low, int high)
    {   
            int pivot=nums[low];
        if (high > low) {
            //在下标 low 和 high 之间随机选择，然后和下标low元素进行交换
            int random = low + new Random().nextInt(high - low);
            pivot=nums[random];
            nums[random]=nums[low];
        }
        
        while(low<high)
        {
            while(low<high && nums[high]>=pivot) high--;
            nums[low]=nums[high];
            while(low<high && nums[low]<=pivot) low++;
            nums[high]=nums[low];
        }
        nums[low]=pivot;
        return low;
    }
```

### 归并排序

归并排序是把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列

```java
    public void mergeSort(int[] arr, int l, int r){
        if(l==r)    return;
        int mid = l+(r-l)/2;
        mergeSort(arr, l, mid);
        mergeSort(arr, mid+1, r);
        merge(arr, l, mid, r);
    }

    private void merge(int[] arr, int l, int mid, int r){
        int[] help = new int[r-l+1];
        int index = 0;
        int p1 = l;
        int p2 = mid + 1;

        while(p1<=mid && p2<=r){
            help[index++] = arr[p1]<arr[p2]?arr[p1++]:arr[p2++];
        }

        while(p1<=mid){
            help[index++] = arr[p1++];
        }

        while(p2<=r){
            help[index++] = arr[p2++];
        }

        for(int i=0;i<help.length;i++){
            arr[l+i] = help[i];
        }
    }
```
### 堆排序

（1)调用PriorityQueue

```
    public int[] HeapSort (int[] arr) {
        // write code here
        PriorityQueue<Integer> queue=new PriorityQueue<>((x,y)->x-y);
        for(int i=0;i<arr.length;i++){
            queue.add(arr[i]);
        }
        for(int i=0;i<arr.length;i++){
            arr[i]=queue.poll();
        }
        return arr;
    }
```
(2)自己实现堆排序

堆的逻辑上是完全二叉树，以数组的形式实现。如果某节点的下标为i，其父节点下标为(i-1)/2。左孩子为2\*i+1,右孩子为2\*i+2。第一个非叶节点为n/2-1。
    
首先构建一个大根堆，只需从第一个非叶子节点开始，从上往下调整。
    
然后将堆顶元素与最后一个元素交换，再把最后一个元素排除到堆外，对剩余的元素重新调整堆。重复此过程直到堆中只有一个元素为止。
```
public int[] HeapSort(int[] arr){

    int n = arr.length;
    for(int i=n/2-1;i>=0;i--){
        sift_down(arr, i, n);
    }

    for(int j=n-1;j>0;j--){
        swap(arr,0,j);
        sift_down(arr, 0, j);
    }
        
    return arr;
}


private void sift_down(int[] arr, int cur, int length){

    int temp = arr[cur];
    for(int child = 2*cur+1;child<length;child=child*2+1){

        if(child+1<length && arr[child]<arr[child+1]){
            child++;
        }
                                                       
        if(arr[child]<temp) break;
        arr[cur] = arr[child];
        cur = child;
    }
    arr[cur] = temp;
}

private void swap(int[] arr, int a, int b){

    int temp = arr[a];
    arr[a] = arr[b];
    arr[b] = temp;
}
```
### 堆
    
sift_down：从上往下调整，主要用于建堆和删除。
    
sift_up：从下往上调整，主要用于插入。
    
add：插入元素。先把元素放到堆的末尾之后。然后将这个元素向上调整。
    
remove：删除元素。先把堆顶元素和堆尾元素交换，然后堆的大小减1，将堆顶元素向下调整。
    
建堆：从第一个非叶子节点开始向下调整。然后将前一个节点向下调整，重复该过程知道第一个节点向下调整完毕。
    
第K大元素：使用小根堆，遍历数组。若堆的大小小于k，数组中元素直接入堆；若堆的大小等于k，先判断堆顶元素是否小于当前元素，若是则堆顶元素出堆然后当前元素入堆；否则就遍历下一个元素。遍历完成后，堆顶元素就是第k大元素。
    
[第K大元素](https://github.com/GrowTowardsSunlight/For-the-interview/blob/master/algorithm/数组中的第K个最大元素.md)
    
堆排序：先建立一个大根堆，然后做k-1次出堆操作，得到正序的数组。
 
[堆排序](#堆排序)

参考代码
```java
import java.util.Arrays;
import java.util.NoSuchElementException;

//小顶堆的代码实现
public class Heap {

    public int size;
    private int[] data;

    public Heap(int capacity){
        data = new int[capacity];
        size = 0;
    }

    // 向下调整，顶端的大值往下调，主要用于删除和建堆,i表示要调整的节点索引，n表示堆的最有一个元素索引
    // 删除时候，i是0，建堆时候i从最后一个节点的父节点依次往前调整
    public void sift_Down(int i) {
        int temp = data[i];
        int child = i*2+1;
        int n = size - 1;//最后一个元素的下标
        while(child<n){
            if (child + 1 <= n && data[child + 1] < data[child])
                child++;
            if (temp < data[child])
                break;
            data[i] = data[child];
            i = child;
            child = i*2+1;
        }
        data[i] = temp;
    }

    // 向上调整，小值往上走,用于增加,往上调整不需要制定最上面的索引，肯定是0
    public void sift_Up(int i) {
        int num = data[i];
        int parent = (i - 1) / 2;
        // data[parent] > num是进入循环的基本条件,father减到0就不会减少了
        // 当n等于0时，father=0；进入死循环，所以当n==0时，需要跳出循环
        while(data[parent] > num && i != 0) {
            data[i] = data[parent];
            i = parent;
            parent = (i - 1) / 2;
        }
        data[i] = num;
    }

    // 删除,n表示堆的最后一个元素的索引
    public int remove() {

        if(size==0) throw new NoSuchElementException();
        int res = data[0];
        if(--size != 0) {
            data[0] = data[size];
            sift_Down(0);
        }
        return res;
    }

    // 增加,i表示要增加的数字，n表示增加位置的索引，是堆的最后一个元素
    public void add(int num) {

        if(size == data.length){
            int len = (int)Math.max(size+1,size*1.5);
            data = Arrays.copyOf(data, len);
        }
        data[size++] = num;
        sift_Up(size-1);
    }

    // 建堆,n表示要建堆的最后一个元素的索引
    public  int[] create(int[] arr, int n) {

        data = Arrays.copyOf(arr,n+1);
        size = n+1;
        for (int i = size / 2 - 1; i >= 0; i--) {
            sift_Down(i);
        }
        return data;
    }

    public static void main(String[] args) {
        int[] data = { 15, 13, 1, 5, 20, 12, 8, 9, 11 };
        Heap heap = new Heap(10);
        int[] res = heap.create(data,data.length-2);
        System.out.println(Arrays.toString(res));
    }
}   
```
