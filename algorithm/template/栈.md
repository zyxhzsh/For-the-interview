### 栈

[实现栈](#实现栈)

[两个栈实现队列](https://github.com/GrowTowardsSunlight/For-the-interview/blob/master/algorithm/data%20strcut/两个栈实现队列.md)

[后缀表达式求值](https://github.com/GrowTowardsSunlight/For-the-interview/blob/master/algorithm/逆波兰表达式求值.md)

[中缀表达式转后缀表达式](#中缀表达式转后缀表达式)

[计算中缀表达式只包含加减](https://github.com/GrowTowardsSunlight/For-the-interview/blob/master/bank/算法.md#计算中缀表达式只包含加减)

[单调栈](https://github.com/GrowTowardsSunlight/For-the-interview/blob/master/algorithm/单调栈.md)

### 实现栈
    
```java
import java.util.Arrays;

public class Stack<E> {

    private Object[] data;
    private int size;

    public Stack(int capacity){

        if(capacity <= 0)   throw new IllegalArgumentException("栈的容量必须大于0");
        data = new Object[capacity];
    }

    public E push(E item){

        if(size==data.length){
            expandCapacity();
        }
        data[size++] = item;
        return item;
    }

    public E pop(){

        if(isEmpty())   throw new IllegalArgumentException("栈为空");
        E temp = (E)data[--size];
        data[size] = null;
        return temp;
    }

    public void expandCapacity(){

        int len = (int)Math.max(size+1, size*1.5);
        data = Arrays.copyOf(data, len);
    }

    public E peek(){

        if(isEmpty())   throw new IllegalArgumentException("栈为空");
        return (E)data[size-1];
    }

    public int size(){

        return size;
    }

    public boolean isEmpty(){

        return size == 0;
    }

    public static void main(String[] args) {

        Stack<Integer> stack = new Stack<>(5);
        for(int i=0;i<6;i++){
            stack.push(i+1);
            System.out.println(stack.size());
        }

        for(int i=0;i<5;i++){
            System.out.println(stack.pop());
        }
    }
}    
```

### 中缀表达式转后缀表达式

利用栈来存储操作符，遍历字符串：

（1）遇到操作数时，直接加入结果。

（2）遇到左括号时，直接入栈

（3）遇到右括号时，栈顶元素不断出栈并加入结果，直到栈顶元素为左括号为止。然后左括号出栈，但不加入结果。

（4）遇到运算符时，若栈不为空，且栈顶元素为运算符，并且栈顶元素的优先级大于等于当前元素时，栈顶元素出栈并加入结果。循环此过程直到不满足条件，最后将当前元素入栈。

遍历结束后，若栈不为空，不断出栈并加入结果。

```java
public class InfixToSuffix {

    public String infixToSuffix(String infix){

        char[] arr = infix.toCharArray();
        StringBuilder sb = new StringBuilder();
        Stack<Character> stack = new Stack<>();
        for(int i=0;i<arr.length;i++){

            char cur = arr[i];
            if(Character.isDigit(cur)){
                sb.append(cur);
                System.out.println(sb);
            }else if(cur == '('){
                stack.push('(');
            }else if(cur == ')'){
                while(stack.peek() != '('){
                    sb.append(stack.pop());
                }
                stack.pop();
            }else{
                while(!stack.isEmpty() && stack.peek() != '(' && priority(stack.peek()) >= priority(cur)){
                    sb.append(stack.pop());
                }
                stack.push(cur);
            }
        }

        while(!stack.isEmpty()){
            sb.append(stack.pop());
        }

        return sb.toString();
    }

    //计算运算符的优先级
    private int priority(char c){
        if(c == '*' || c == '/'){
            return 1;
        }else{
            return -1;
        }
    }

    //测试
    public static void main(String[] args) {
        String infix = "1+(2+3)*4–5";
        InfixToSuffix test = new InfixToSuffix();
        String res = test.infixToSuffix(infix);
        System.out.println(res);
    }
}
```
