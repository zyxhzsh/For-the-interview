2020年9月19日

[力扣](https://leetcode-cn.com/problems/task-scheduler/)

[思路一](#思路一)

[思路二](#思路二)

**描述**

给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。
任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。

然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。
你需要计算完成所有任务所需要的最短时间。

示例 ：
```
输入：tasks = ["A","A","A","B","B","B"], n = 2
输出：8
解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B.
     在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 
```

#### 思路一

排序

我们可以想到按照任务的数量来安排它们，即一种任务的出现次数越多，我们就越早地安排。

我们规定 n + 1 个任务为一轮，这样的好处是同一轮中一个任务最多只能被安排一次。在每一轮中，我们将当前的任务按照它们剩余的次数降序排序，并选择剩余次数最多的 n + 1 个任务依次执行。
如果任务的种类 t 少于 n + 1 个，就只选择全部的 t 种任务，其余的时间空闲。这样做的正确性在于，由于冷却时间的存在，出现次数较多的那些任务如果不尽早安排，将会导致大量空闲时间的出现，
因此贪心地将出现次数较多的任务安排在前面是合理的。同时我们可以保证，这一轮的第 k 个任务距离上一次执行至少有 n 个单位的冷却时间。

时间复杂度：O(time)，由于我们给每个任务都安排了时间，因此时间复杂度和最终的答案成正比。

空间复杂度：O(1)。

```java
class Solution {
    public int leastInterval(char[] tasks, int n) {
        int[] array = new int[26];
        for(char chr:tasks){
            array[chr-'A']++;//统计每个任务的数量
        }
        Arrays.sort(array);//按任务数量从小到大排序
        int time=0;
        while(array[25]>0){
            
            for(int i=0;i<=n;i++){
                if(array[25]==0)//上一轮结束后数量最多的任务，当前为0。就跳出当前循环重新排序，看还有没有任务。
                    break;
                if(i<26 && array[25-i]>0)
                    array[25-i]--;
                time++;
            }
            Arrays.sort(array);//一轮过后重新排序
        }
        return time; 
    }
}
```

#### 思路二

[填桶思路](https://leetcode-cn.com/problems/task-scheduler/solution/tian-tong-si-lu-you-tu-kan-wan-jiu-dong-by-mei-jia/)

先算出每个任务的个数，并排序,记单个任务执行次数最多的为max次。

任务种类较少，填不满桶时
```
摆列顺序：先放任务个数大的，再放小的；从上到下，从左到右放。
执行顺序：左到右，上到下
桶并不是完整的矩形，最后一行由maxcount（数量最多的任务的个数）决定。由于高度是最大值，不可能存在同一行出现相同的任务。
桶宽为n+1。最短时间很明显主要由最后一行的个数maxCount决定。
最短时间：(n + 1) * (max - 1) + maxCount，也就是桶的大小。
```
任务种类较多，桶放不下时
```
摆放顺序：在前面的基础上，桶不够时往桶右边补，顺序仍然是从上到下，从左到右放。
执行顺序：左到右，上到下。
由于高度是最大值，不可能存在同一行出现相同的任务，而宽度大于等于 n + 1，符合要求。由于不含待命格子，最短时间很明显由总任务个数决定。
最短时间：tasks.length
```
最短时间：在填不满桶时，最短时间为 (n + 1) * (max - 1) + maxCount，也就是桶的大小；
在桶放不下时，最短时间是tasks.length。综合起来就是它两的最大值。因为存在空闲时间时肯定是第一种大，不存在空闲时间时肯定是第二种大于或等于第一种。
思路一如果 maxCount > n + 1，由于宽度早已溢出，此时都不需要有填桶这个概念了，你可以直接把这种情况归为思路二

时间复杂度：O(tasks.length)。
空间复杂度：O(1)

```java
class Solution {
    public int leastInterval(char[] tasks, int n) {
        int[] array = new int[26];
        for(char chr:tasks){
            array[chr-'A']++;//统计每个任务的数量
        }

        int max=0;
        //计算单个任务最多出现的次数
        for(int i:array){
            max=Math.max(max,i);
        }

        int maxcount=0;
        //计算次数最多的任务的个数
        for(int i:array){
            if(max==i)
                maxcount++;
        }
        return Math.max(tasks.length, (n+1)*(max-1)+maxcount);
    }
}
```
