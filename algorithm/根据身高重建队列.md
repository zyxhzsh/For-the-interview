2020年10月2日

[力扣](https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/gen-ju-shen-gao-zhong-jian-dui-lie-by-leetcode/)

**描述**

假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。

注意：总人数少于1100人。

示例
```
输入:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

输出:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
```

#### 思路

贪心

当队列中所有人的 (h,k) 都是相同的高度 h，只有 k 不同时，解决方案很简单：每个人在队列的索引 index = k。

即使不是所有人都是同一高度，这个策略也是可行的。因为个子矮的人相对于个子高的人是 “看不见” 的，所以可以先安排个子高的人。

矮的人相对于高的人是看不见的：因为k的值是前面比自己高或等高的人的个数。先处理高的人，满足k的条件后，再处理矮的人是不会破坏这个条件的。
相对矮的人插入对应的k位置的话，可以保证结果中的k条件不被破坏（因为此时结果中高的人已经站好了，矮的无法影响他们），但是因为矮的人要占据一个位置的，所以高的人只能往后面挪动。

该策略可以递归进行：

将最高的人按照 k 值升序排序，然后将它们放置到输出队列中与 k 值相等的索引位置上。

按降序取下一个高度，同样按 k 值对该身高的人升序排序，然后逐个插入到输出队列中与 k 值相等的索引位置上。直到完成为止。

（1）排序：按高度降序排列。在同一高度的人中，按 k 值的升序排列。
（2）逐个地把它们放在输出队列中，索引等于它们的 k 值。
（3）返回输出队列

时间复杂度：O(n^2)。排序使用了O(nlgn)的时间，每个人插入到输出序列中要O(k)的时间。总时间复杂度为O(∑k)(k=0,...n-1)=O(n^2)。

空间复杂度：O(n)，输出队列使用的空间。


```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people, new Comparator<int[]>(){
            public int compare(int[] p1, int[] p2){
                return p1[0]==p2[0]?p1[1]-p2[1]:p2[0]-p1[0];
                //高度不同的按高度从大到小排序，高度相同的按k从小到大排序。
            }
        });

        List<int[]> res = new LinkedList<>();
        for(int[] p:people){
            res.add(p[1], p);
        }

        return res.toArray(new int[people.length][2]);
    }
}
```

